{"ast":null,"code":"import React, { useMemo, useState, useReducer, useCallback, useEffect, useRef, useContext, useLayoutEffect, forwardRef, useImperativeHandle, Children } from 'react';\nimport { createPortal } from 'react-dom';\nimport isDeepEqual from 'fast-deep-equal';\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\nconst APILoadingStatus = {\n  NOT_LOADED: 'NOT_LOADED',\n  LOADING: 'LOADING',\n  LOADED: 'LOADED',\n  FAILED: 'FAILED',\n  AUTH_FAILURE: 'AUTH_FAILURE'\n};\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nclass GoogleMapsApiLoader {\n  /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */\n  static async load(params, onLoadingStatusChange) {\n    var _window$google;\n    const libraries = params.libraries ? params.libraries.split(',') : [];\n    const serializedParams = this.serializeParams(params);\n    this.listeners.push(onLoadingStatusChange);\n    // Note: if `google.maps.importLibrary` has been defined externally, we\n    //   assume that loading is complete and successful.\n    //   If it was defined by a previous call to this method, a warning\n    //   message is logged if there are differences in api-parameters used\n    //   for both calls.\n    if ((_window$google = window.google) != null && (_window$google = _window$google.maps) != null && _window$google.importLibrary) {\n      // no serialized parameters means it was loaded externally\n      if (!this.serializedApiParams) {\n        this.loadingStatus = APILoadingStatus.LOADED;\n      }\n      this.notifyLoadingStatusListeners();\n    } else {\n      this.serializedApiParams = serializedParams;\n      this.initImportLibrary(params);\n    }\n    if (this.serializedApiParams && this.serializedApiParams !== serializedParams) {\n      console.warn(\"[google-maps-api-loader] The maps API has already been loaded \" + \"with different parameters and will not be loaded again. Refresh the \" + \"page for new values to have effect.\");\n    }\n    const librariesToLoad = ['maps', ...libraries];\n    await Promise.all(librariesToLoad.map(name => google.maps.importLibrary(name)));\n  }\n  /**\n   * Serialize the paramters used to load the library for easier comparison.\n   */\n  static serializeParams(params) {\n    return [params.v, params.key, params.language, params.region, params.authReferrerPolicy, params.solutionChannel].join('/');\n  }\n  /**\n   * Creates the global `google.maps.importLibrary` function for bootstrapping.\n   * This is essentially a formatted version of the dynamic loading script\n   * from the official documentation with some minor adjustments.\n   *\n   * The created importLibrary function will load the Google Maps JavaScript API,\n   * which will then replace the `google.maps.importLibrary` function with the full\n   * implementation.\n   *\n   * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n   */\n  static initImportLibrary(params) {\n    if (!window.google) window.google = {};\n    if (!window.google.maps) window.google.maps = {};\n    if (window.google.maps['importLibrary']) {\n      console.error('[google-maps-api-loader-internal]: initImportLibrary must only be called once');\n      return;\n    }\n    let apiPromise = null;\n    const loadApi = () => {\n      if (apiPromise) return apiPromise;\n      apiPromise = new Promise((resolve, reject) => {\n        var _document$querySelect;\n        const scriptElement = document.createElement('script');\n        const urlParams = new URLSearchParams();\n        for (const [key, value] of Object.entries(params)) {\n          const urlParamName = key.replace(/[A-Z]/g, t => '_' + t[0].toLowerCase());\n          urlParams.set(urlParamName, value);\n        }\n        urlParams.set('loading', 'async');\n        urlParams.set('callback', '__googleMapsCallback__');\n        scriptElement.async = true;\n        scriptElement.src = MAPS_API_BASE_URL + \"?\" + urlParams.toString();\n        scriptElement.nonce = ((_document$querySelect = document.querySelector('script[nonce]')) == null ? void 0 : _document$querySelect.nonce) || '';\n        scriptElement.onerror = () => {\n          this.loadingStatus = APILoadingStatus.FAILED;\n          this.notifyLoadingStatusListeners();\n          reject(new Error('The Google Maps JavaScript API could not load.'));\n        };\n        window.__googleMapsCallback__ = () => {\n          this.loadingStatus = APILoadingStatus.LOADED;\n          this.notifyLoadingStatusListeners();\n          resolve();\n        };\n        window.gm_authFailure = () => {\n          this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n          this.notifyLoadingStatusListeners();\n        };\n        this.loadingStatus = APILoadingStatus.LOADING;\n        this.notifyLoadingStatusListeners();\n        document.head.append(scriptElement);\n      });\n      return apiPromise;\n    };\n    // for the first load, we declare an importLibrary function that will\n    // be overwritten once the api is loaded.\n    google.maps.importLibrary = libraryName => loadApi().then(() => google.maps.importLibrary(libraryName));\n  }\n  /**\n   * Calls all registered loadingStatusListeners after a status update.\n   */\n  static notifyLoadingStatusListeners() {\n    for (const fn of this.listeners) {\n      fn(this.loadingStatus);\n    }\n  }\n}\n/**\n * The current loadingStatus of the API.\n */\nGoogleMapsApiLoader.loadingStatus = APILoadingStatus.NOT_LOADED;\n/**\n * The parameters used for first loading the API.\n */\nGoogleMapsApiLoader.serializedApiParams = void 0;\n/**\n * A list of functions to be notified when the loading status changes.\n */\nGoogleMapsApiLoader.listeners = [];\nconst _excluded$3 = [\"onLoad\", \"apiKey\", \"version\", \"libraries\"],\n  _excluded2 = [\"children\"];\nconst APIProviderContext = React.createContext(null);\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n  const [mapInstances, setMapInstances] = useState({});\n  const addMapInstance = function (mapInstance) {\n    let id = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'default';\n    setMapInstances(instances => _extends({}, instances, {\n      [id]: mapInstance\n    }));\n  };\n  const removeMapInstance = function () {\n    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMapInstances(_ref => {\n      let remaining = _objectWithoutPropertiesLoose(_ref, [id].map(_toPropertyKey));\n      return remaining;\n    });\n  };\n  const clearMapInstances = () => {\n    setMapInstances({});\n  };\n  return {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  };\n}\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props) {\n  const {\n      onLoad,\n      apiKey,\n      version,\n      libraries = []\n    } = props,\n    otherApiParams = _objectWithoutPropertiesLoose(props, _excluded$3);\n  const [status, setStatus] = useState(GoogleMapsApiLoader.loadingStatus);\n  const [loadedLibraries, addLoadedLibrary] = useReducer((loadedLibraries, action) => {\n    return _extends({}, loadedLibraries, {\n      [action.name]: action.value\n    });\n  }, {});\n  const librariesString = useMemo(() => libraries == null ? void 0 : libraries.join(','), [libraries]);\n  const serializedParams = useMemo(() => JSON.stringify(_extends({\n    apiKey,\n    version\n  }, otherApiParams)), [apiKey, version, otherApiParams]);\n  const importLibrary = useCallback(async name => {\n    var _google;\n    if (loadedLibraries[name]) {\n      return loadedLibraries[name];\n    }\n    if (!((_google = google) != null && (_google = _google.maps) != null && _google.importLibrary)) {\n      throw new Error('[api-provider-internal] importLibrary was called before ' + 'google.maps.importLibrary was defined.');\n    }\n    const res = await window.google.maps.importLibrary(name);\n    addLoadedLibrary({\n      name,\n      value: res\n    });\n    return res;\n  }, [loadedLibraries]);\n  useEffect(() => {\n    (async () => {\n      try {\n        const params = _extends({\n          key: apiKey\n        }, otherApiParams);\n        if (version) params.v = version;\n        if ((librariesString == null ? void 0 : librariesString.length) > 0) params.libraries = librariesString;\n        await GoogleMapsApiLoader.load(params, status => setStatus(status));\n        for (const name of ['core', 'maps', ...libraries]) {\n          await importLibrary(name);\n        }\n        if (onLoad) {\n          onLoad();\n        }\n      } catch (error) {\n        console.error('<ApiProvider> failed to load Google Maps API', error);\n      }\n    })();\n  },\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [apiKey, librariesString, serializedParams]);\n  return {\n    status,\n    loadedLibraries,\n    importLibrary\n  };\n}\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */\nconst APIProvider = props => {\n  const {\n      children\n    } = props,\n    loaderProps = _objectWithoutPropertiesLoose(props, _excluded2);\n  const {\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances\n  } = useMapInstances();\n  const {\n    status,\n    loadedLibraries,\n    importLibrary\n  } = useGoogleMapsApiLoader(loaderProps);\n  const contextValue = useMemo(() => ({\n    mapInstances,\n    addMapInstance,\n    removeMapInstance,\n    clearMapInstances,\n    status,\n    loadedLibraries,\n    importLibrary\n  }), [mapInstances, addMapInstance, removeMapInstance, clearMapInstances, status, loadedLibraries, importLibrary]);\n  return /*#__PURE__*/React.createElement(APIProviderContext.Provider, {\n    value: contextValue\n  }, children);\n};\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nfunction useMapEvents(map, props) {\n  // note: calling a useEffect hook from within a loop is prohibited by the\n  // rules of hooks, but it's ok here since it's unconditional and the number\n  // and order of iterations is always strictly the same.\n  // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n  for (const propName of eventPropNames) {\n    // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n    //   a proper solution seems way too complicated right now\n    const handler = props[propName];\n    const eventType = propNameToEventType[propName];\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!map) return;\n      if (!handler) return;\n      const listener = google.maps.event.addListener(map, eventType, ev => {\n        handler(createMapEvent(eventType, map, ev));\n      });\n      return () => listener.remove();\n    }, [map, eventType, handler]);\n  }\n}\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(type, map, srcEvent) {\n  const ev = {\n    type,\n    map,\n    detail: {},\n    stoppable: false,\n    stop: () => {}\n  };\n  if (cameraEventTypes.includes(type)) {\n    const camEvent = ev;\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n      console.warn('[createEvent] at least one of the values from the map ' + 'returned undefined. This is not expected to happen. Please ' + 'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n    }\n    camEvent.detail = {\n      center: (center == null ? void 0 : center.toJSON()) || {\n        lat: 0,\n        lng: 0\n      },\n      zoom: zoom || 0,\n      heading: heading,\n      tilt: tilt,\n      bounds: (bounds == null ? void 0 : bounds.toJSON()) || {\n        north: 90,\n        east: 180,\n        south: -90,\n        west: -180\n      }\n    };\n    return camEvent;\n  } else if (mouseEventTypes.includes(type)) {\n    var _srcEvent$latLng;\n    if (!srcEvent) throw new Error('[createEvent] mouse events must provide a srcEvent');\n    const mouseEvent = ev;\n    mouseEvent.domEvent = srcEvent.domEvent;\n    mouseEvent.stoppable = true;\n    mouseEvent.stop = () => srcEvent.stop();\n    mouseEvent.detail = {\n      latLng: ((_srcEvent$latLng = srcEvent.latLng) == null ? void 0 : _srcEvent$latLng.toJSON()) || null,\n      placeId: srcEvent.placeId\n    };\n    return mouseEvent;\n  }\n  return ev;\n}\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType = {\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onContextmenu: 'contextmenu',\n  onDblclick: 'dblclick',\n  onDrag: 'drag',\n  onDragend: 'dragend',\n  onDragstart: 'dragstart',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n  onMapCapabilitiesChanged: 'mapcapabilities_changed',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMousemove: 'mousemove',\n  onMouseout: 'mouseout',\n  onMouseover: 'mouseover',\n  onProjectionChanged: 'projection_changed',\n  onRenderingTypeChanged: 'renderingtype_changed',\n  onTilesLoaded: 'tilesloaded',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed',\n  // note: onCameraChanged is an alias for the bounds_changed event,\n  // since that is going to be fired in every situation where the camera is\n  // updated.\n  onCameraChanged: 'bounds_changed'\n};\nconst cameraEventTypes = ['bounds_changed', 'center_changed', 'heading_changed', 'projection_changed', 'tilt_changed', 'zoom_changed'];\nconst mouseEventTypes = ['click', 'contextmenu', 'dblclick', 'mousemove', 'mouseout', 'mouseover'];\nconst eventPropNames = Object.keys(propNameToEventType);\nfunction useDeepCompareEffect(effect, deps) {\n  const ref = useRef(undefined);\n  if (!ref.current || !isDeepEqual(deps, ref.current)) {\n    ref.current = deps;\n  }\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(effect, ref.current);\n}\nconst mapOptionKeys = new Set(['backgroundColor', 'clickableIcons', 'controlSize', 'disableDefaultUI', 'disableDoubleClickZoom', 'draggable', 'draggableCursor', 'draggingCursor', 'fullscreenControl', 'fullscreenControlOptions', 'gestureHandling', 'isFractionalZoomEnabled', 'keyboardShortcuts', 'mapTypeControl', 'mapTypeControlOptions', 'mapTypeId', 'maxZoom', 'minZoom', 'noClear', 'panControl', 'panControlOptions', 'restriction', 'rotateControl', 'rotateControlOptions', 'scaleControl', 'scaleControlOptions', 'scrollwheel', 'streetView', 'streetViewControl', 'streetViewControlOptions', 'styles', 'zoomControl', 'zoomControlOptions']);\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nfunction useMapOptions(map, mapProps) {\n  /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor via mapOptions.\n   */\n  const mapOptions = {};\n  const keys = Object.keys(mapProps);\n  for (const key of keys) {\n    if (!mapOptionKeys.has(key)) continue;\n    mapOptions[key] = mapProps[key];\n  }\n  // update the map options when mapOptions is changed\n  // Note: due to the destructuring above, mapOptions will be seen as changed\n  //   with every re-render, so we're assuming the maps-api will properly\n  //   deal with unchanged option-values passed into setOptions.\n  useDeepCompareEffect(() => {\n    if (!map) return;\n    map.setOptions(mapOptions);\n  }, [mapOptions]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}\nfunction useApiLoadingStatus() {\n  var _useContext;\n  return ((_useContext = useContext(APIProviderContext)) == null ? void 0 : _useContext.status) || APILoadingStatus.NOT_LOADED;\n}\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nfunction useDeckGLCameraUpdate(map, props) {\n  const {\n    viewport,\n    viewState\n  } = props;\n  const isDeckGlControlled = !!viewport;\n  useLayoutEffect(() => {\n    if (!map || !viewState) return;\n    const {\n      latitude,\n      longitude,\n      bearing: heading,\n      pitch: tilt,\n      zoom\n    } = viewState;\n    map.moveCamera({\n      center: {\n        lat: latitude,\n        lng: longitude\n      },\n      heading,\n      tilt,\n      zoom: zoom + 1\n    });\n  }, [map, viewState]);\n  return isDeckGlControlled;\n}\nfunction isLatLngLiteral(obj) {\n  if (!obj || typeof obj !== 'object') return false;\n  if (!('lat' in obj && 'lng' in obj)) return false;\n  return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\nfunction latLngEquals(a, b) {\n  if (!a || !b) return false;\n  const A = toLatLngLiteral(a);\n  const B = toLatLngLiteral(b);\n  if (A.lat !== B.lat || A.lng !== B.lng) return false;\n  return true;\n}\nfunction toLatLngLiteral(obj) {\n  if (isLatLngLiteral(obj)) return obj;\n  return obj.toJSON();\n}\nfunction useMapCameraParams(map, cameraStateRef, mapProps) {\n  const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n  let lat = null;\n  let lng = null;\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat;\n    lng = center.lng;\n  }\n  const zoom = Number.isFinite(mapProps.zoom) ? mapProps.zoom : null;\n  const heading = Number.isFinite(mapProps.heading) ? mapProps.heading : null;\n  const tilt = Number.isFinite(mapProps.tilt) ? mapProps.tilt : null;\n  // the following effect runs for every render of the map component and checks\n  // if there are differences between the known state of the map instance\n  // (cameraStateRef, which is updated by all bounds_changed events) and the\n  // desired state in the props.\n  useLayoutEffect(() => {\n    if (!map) return;\n    const nextCamera = {};\n    let needsUpdate = false;\n    if (lat !== null && lng !== null && (cameraStateRef.current.center.lat !== lat || cameraStateRef.current.center.lng !== lng)) {\n      nextCamera.center = {\n        lat,\n        lng\n      };\n      needsUpdate = true;\n    }\n    if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n      nextCamera.zoom = zoom;\n      needsUpdate = true;\n    }\n    if (heading !== null && cameraStateRef.current.heading !== heading) {\n      nextCamera.heading = heading;\n      needsUpdate = true;\n    }\n    if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n      nextCamera.tilt = tilt;\n      needsUpdate = true;\n    }\n    if (needsUpdate) {\n      map.moveCamera(nextCamera);\n    }\n  });\n}\nconst AuthFailureMessage = () => {\n  const style = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 999,\n    display: 'flex',\n    flexFlow: 'column nowrap',\n    textAlign: 'center',\n    justifyContent: 'center',\n    fontSize: '.8rem',\n    color: 'rgba(0,0,0,0.6)',\n    background: '#dddddd',\n    padding: '1rem 1.5rem'\n  };\n  return /*#__PURE__*/React.createElement(\"div\", {\n    style: style\n  }, /*#__PURE__*/React.createElement(\"h2\", null, \"Error: AuthFailure\"), /*#__PURE__*/React.createElement(\"p\", null, \"A problem with your API key prevents the map from rendering correctly. Please make sure the value of the \", /*#__PURE__*/React.createElement(\"code\", null, \"APIProvider.apiKey\"), \" prop is correct. Check the error-message in the console for further details.\"));\n};\nfunction useCallbackRef() {\n  const [el, setEl] = useState(null);\n  const ref = useCallback(value => setEl(value), [setEl]);\n  return [el, ref];\n}\n\n/**\n * Hook to check if the Google Maps API is loaded\n */\nfunction useApiIsLoaded() {\n  const status = useApiLoadingStatus();\n  return status === APILoadingStatus.LOADED;\n}\nfunction useForceUpdate() {\n  const [, forceUpdate] = useReducer(x => x + 1, 0);\n  return forceUpdate;\n}\nfunction handleBoundsChange(map, ref) {\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  const heading = map.getHeading() || 0;\n  const tilt = map.getTilt() || 0;\n  const bounds = map.getBounds();\n  if (!center || !bounds || !Number.isFinite(zoom)) {\n    console.warn('[useTrackedCameraState] at least one of the values from the map ' + 'returned undefined. This is not expected to happen. Please ' + 'report an issue at https://github.com/visgl/react-google-maps/issues/new');\n  }\n  // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n  Object.assign(ref.current, {\n    center: (center == null ? void 0 : center.toJSON()) || {\n      lat: 0,\n      lng: 0\n    },\n    zoom: zoom || 0,\n    heading: heading,\n    tilt: tilt\n  });\n}\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */\nfunction useTrackedCameraStateRef(map) {\n  const forceUpdate = useForceUpdate();\n  const ref = useRef({\n    center: {\n      lat: 0,\n      lng: 0\n    },\n    heading: 0,\n    tilt: 0,\n    zoom: 0\n  });\n  // Record camera state with every bounds_changed event dispatched by the map.\n  // This data is used to prevent feeding these values back to the\n  // map-instance when a typical \"controlled component\" setup (state variable is\n  // fed into and updated by the map).\n  useEffect(() => {\n    if (!map) return;\n    const listener = google.maps.event.addListener(map, 'bounds_changed', () => {\n      handleBoundsChange(map, ref);\n      // When an event is occured, we have to update during the next cycle.\n      // The application could decide to ignore the event and not update any\n      // camera props of the map, meaning that in that case we will have to\n      // 'undo' the change to the camera.\n      forceUpdate();\n    });\n    return () => listener.remove();\n  }, [map, forceUpdate]);\n  return ref;\n}\nconst _excluded$2 = [\"id\", \"defaultBounds\", \"defaultCenter\", \"defaultZoom\", \"defaultHeading\", \"defaultTilt\"];\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nfunction useMapInstance(props, context) {\n  const apiIsLoaded = useApiIsLoaded();\n  const [map, setMap] = useState(null);\n  const [container, containerRef] = useCallbackRef();\n  const cameraStateRef = useTrackedCameraStateRef(map);\n  const {\n      id,\n      defaultBounds,\n      defaultCenter,\n      defaultZoom,\n      defaultHeading,\n      defaultTilt\n    } = props,\n    mapOptions = _objectWithoutPropertiesLoose(props, _excluded$2);\n  // apply default camera props if available and not overwritten by controlled props\n  if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n  if (!mapOptions.zoom && Number.isFinite(defaultZoom)) mapOptions.zoom = defaultZoom;\n  if (!mapOptions.heading && Number.isFinite(defaultHeading)) mapOptions.heading = defaultHeading;\n  if (!mapOptions.tilt && Number.isFinite(defaultTilt)) mapOptions.tilt = defaultTilt;\n  for (const key of Object.keys(mapOptions)) if (mapOptions[key] === undefined) delete mapOptions[key];\n  const savedMapStateRef = useRef();\n  // create the map instance and register it in the context\n  useEffect(() => {\n    if (!container || !apiIsLoaded) return;\n    const {\n      addMapInstance,\n      removeMapInstance\n    } = context;\n    const mapId = props.mapId;\n    const newMap = new google.maps.Map(container, mapOptions);\n    setMap(newMap);\n    addMapInstance(newMap, id);\n    if (defaultBounds) {\n      newMap.fitBounds(defaultBounds);\n    }\n    // the savedMapState is used to restore the camera parameters when the mapId is changed\n    if (savedMapStateRef.current) {\n      const {\n        mapId: savedMapId,\n        cameraState: savedCameraState\n      } = savedMapStateRef.current;\n      if (savedMapId !== mapId) {\n        newMap.setOptions(savedCameraState);\n      }\n    }\n    return () => {\n      savedMapStateRef.current = {\n        mapId,\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        cameraState: cameraStateRef.current\n      };\n      // remove all event-listeners to minimize memory-leaks\n      google.maps.event.clearInstanceListeners(newMap);\n      setMap(null);\n      removeMapInstance(id);\n    };\n  },\n  // some dependencies are ignored in the list below:\n  //  - defaultBounds and the default* camera props will only be used once, and\n  //    changes should be ignored\n  //  - mapOptions has special hooks that take care of updating the options\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  [container, apiIsLoaded, id, props.mapId]);\n  return [map, containerRef, cameraStateRef];\n}\nconst GoogleMapsContext = React.createContext(null);\nconst Map = props => {\n  const {\n    children,\n    id,\n    className,\n    style\n  } = props;\n  const context = useContext(APIProviderContext);\n  const loadingStatus = useApiLoadingStatus();\n  if (!context) {\n    throw new Error('<Map> can only be used inside an <ApiProvider> component.');\n  }\n  const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n  useMapCameraParams(map, cameraStateRef, props);\n  useMapEvents(map, props);\n  useMapOptions(map, props);\n  const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n  const isControlledExternally = !!props.controlled;\n  // disable interactions with the map for externally controlled maps\n  useEffect(() => {\n    if (!map) return;\n    // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n    //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n    //   any default map controls pretty much useless\n    if (isDeckGlControlled) {\n      map.setOptions({\n        disableDefaultUI: true\n      });\n    }\n    // disable all control-inputs when the map is controlled externally\n    if (isDeckGlControlled || isControlledExternally) {\n      map.setOptions({\n        gestureHandling: 'none',\n        keyboardShortcuts: false\n      });\n    }\n    return () => {\n      map.setOptions({\n        gestureHandling: props.gestureHandling,\n        keyboardShortcuts: props.keyboardShortcuts\n      });\n    };\n  }, [map, isDeckGlControlled, isControlledExternally, props.gestureHandling, props.keyboardShortcuts]);\n  // setup a stable cameraOptions object that can be used as dependency\n  const center = props.center ? toLatLngLiteral(props.center) : null;\n  let lat = null;\n  let lng = null;\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat;\n    lng = center.lng;\n  }\n  const cameraOptions = useMemo(() => {\n    var _lat, _lng, _props$zoom, _props$heading, _props$tilt;\n    return {\n      center: {\n        lat: (_lat = lat) != null ? _lat : 0,\n        lng: (_lng = lng) != null ? _lng : 0\n      },\n      zoom: (_props$zoom = props.zoom) != null ? _props$zoom : 0,\n      heading: (_props$heading = props.heading) != null ? _props$heading : 0,\n      tilt: (_props$tilt = props.tilt) != null ? _props$tilt : 0\n    };\n  }, [lat, lng, props.zoom, props.heading, props.tilt]);\n  // externally controlled mode: reject all camera changes that don't correspond to changes in props\n  useLayoutEffect(() => {\n    if (!map || !isControlledExternally) return;\n    map.moveCamera(cameraOptions);\n    const listener = map.addListener('bounds_changed', () => {\n      map.moveCamera(cameraOptions);\n    });\n    return () => listener.remove();\n  }, [map, isControlledExternally, cameraOptions]);\n  const combinedStyle = useMemo(() => _extends({\n    width: '100%',\n    height: '100%',\n    // when using deckgl, the map should be sent to the back\n    zIndex: isDeckGlControlled ? -1 : 0\n  }, style), [style, isDeckGlControlled]);\n  const contextValue = useMemo(() => ({\n    map\n  }), [map]);\n  if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n    return /*#__PURE__*/React.createElement(\"div\", {\n      style: _extends({\n        position: 'relative'\n      }, className ? {} : combinedStyle),\n      className: className\n    }, /*#__PURE__*/React.createElement(AuthFailureMessage, null));\n  }\n  return /*#__PURE__*/React.createElement(\"div\", _extends({\n    ref: mapRef,\n    \"data-testid\": 'map',\n    style: className ? undefined : combinedStyle,\n    className: className\n  }, id ? {\n    id\n  } : {}), map ? /*#__PURE__*/React.createElement(GoogleMapsContext.Provider, {\n    value: contextValue\n  }, children) : null);\n};\nMap.deckGLViewProps = true;\nfunction useMapsLibrary(name) {\n  const apiIsLoaded = useApiIsLoaded();\n  const ctx = useContext(APIProviderContext);\n  useEffect(() => {\n    if (!apiIsLoaded || !ctx) return;\n    // Trigger loading the libraries via our proxy-method.\n    // The returned promise is ignored, since importLibrary will update loadedLibraries\n    // list in the context, triggering a re-render.\n    void ctx.importLibrary(name);\n  }, [apiIsLoaded, ctx, name]);\n  return (ctx == null ? void 0 : ctx.loadedLibraries[name]) || null;\n}\n\n/* eslint-disable complexity */\nconst AdvancedMarkerContext = React.createContext(null);\nfunction useAdvancedMarker(props) {\n  var _useContext;\n  const [marker, setMarker] = useState(null);\n  const [contentContainer, setContentContainer] = useState(null);\n  const map = (_useContext = useContext(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const markerLibrary = useMapsLibrary('marker');\n  const {\n    children,\n    className,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    collisionBehavior,\n    draggable,\n    position,\n    title,\n    zIndex\n  } = props;\n  const numChilds = Children.count(children);\n  // create marker instance and add it to the map when map becomes available\n  useEffect(() => {\n    if (!map || !markerLibrary) return;\n    const newMarker = new markerLibrary.AdvancedMarkerElement();\n    newMarker.map = map;\n    setMarker(newMarker);\n    // create container for marker content if there are children\n    if (numChilds > 0) {\n      const el = document.createElement('div');\n      if (className) el.className = className;\n      newMarker.content = el;\n      setContentContainer(el);\n    }\n    return () => {\n      newMarker.map = null;\n      setMarker(null);\n      setContentContainer(null);\n    };\n    // We do not want to re-render the whole marker when the className changes\n    // because that causes a short flickering of the marker.\n    // The className update is handled in the useEffect below.\n    // Excluding the className from the dependency array onm purpose here\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map, markerLibrary, numChilds]);\n  // update className of advanced marker element\n  useEffect(() => {\n    if (!contentContainer) return;\n    contentContainer.className = className != null ? className : '';\n  }, [contentContainer, className]);\n  // bind all marker events\n  useEffect(() => {\n    if (!marker) return;\n    const gme = google.maps.event;\n    if (onClick) gme.addListener(marker, 'click', onClick);\n    if (onDrag) gme.addListener(marker, 'drag', onDrag);\n    if (onDragStart) gme.addListener(marker, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(marker, 'dragend', onDragEnd);\n    if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n      console.warn('You need to set the marker to draggable to listen to drag-events.');\n    }\n    const m = marker;\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDragStart, onDrag, onDragEnd]);\n  // update other marker props when changed\n  useEffect(() => {\n    if (!marker) return;\n    if (position !== undefined) marker.position = position;\n    if (draggable !== undefined) marker.gmpDraggable = draggable;\n    if (collisionBehavior !== undefined) marker.collisionBehavior = collisionBehavior;\n    if (zIndex !== undefined) marker.zIndex = zIndex;\n    if (typeof title === 'string') marker.title = title;\n  }, [marker, position, draggable, collisionBehavior, zIndex, title]);\n  return [marker, contentContainer];\n}\nconst AdvancedMarker = forwardRef((props, ref) => {\n  const {\n    children\n  } = props;\n  const [marker, contentContainer] = useAdvancedMarker(props);\n  const advancedMarkerContextValue = useMemo(() => marker ? {\n    marker\n  } : null, [marker]);\n  useImperativeHandle(ref, () => marker, [marker]);\n  if (!marker) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(AdvancedMarkerContext.Provider, {\n    value: advancedMarkerContextValue\n  }, contentContainer !== null && createPortal(children, contentContainer));\n});\nfunction useAdvancedMarkerRef() {\n  const [marker, setMarker] = useState(null);\n  const refCallback = useCallback(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\nconst _excluded$1 = [\"children\", \"anchor\", \"shouldFocus\", \"onCloseClick\"];\n/**\n * Component to render a Google Maps Info Window\n */\nconst InfoWindow = props => {\n  var _useContext;\n  const {\n      children,\n      anchor,\n      shouldFocus,\n      onCloseClick\n    } = props,\n    infoWindowOptions = _objectWithoutPropertiesLoose(props, _excluded$1);\n  const map = (_useContext = useContext(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const infoWindowRef = useRef(null);\n  const [contentContainer, setContentContainer] = useState(null);\n  // create infowindow once map is available\n  useEffect(() => {\n    if (!map) return;\n    const newInfowindow = new google.maps.InfoWindow(infoWindowOptions);\n    // Add content to info window\n    const el = document.createElement('div');\n    newInfowindow.setContent(el);\n    infoWindowRef.current = newInfowindow;\n    setContentContainer(el);\n    // Cleanup info window and event listeners on unmount\n    return () => {\n      google.maps.event.clearInstanceListeners(newInfowindow);\n      newInfowindow.close();\n      el.remove();\n      setContentContainer(null);\n    };\n    // `infoWindowOptions` is missing from dependencies:\n    //\n    // we don't want to re-render a whole new infowindow\n    // when the options change to prevent flickering.\n    // Update of infoWindow options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map, children]);\n  // Update infoWindowOptions\n  useEffect(() => {\n    var _infoWindowRef$curren;\n    (_infoWindowRef$curren = infoWindowRef.current) == null || _infoWindowRef$curren.setOptions(infoWindowOptions);\n  }, [infoWindowOptions]);\n  // Handle the close click callback\n  useEffect(() => {\n    if (!infoWindowRef.current) return;\n    let listener = null;\n    if (onCloseClick) {\n      listener = google.maps.event.addListener(infoWindowRef.current, 'closeclick', onCloseClick);\n    }\n    return () => {\n      if (listener) listener.remove();\n    };\n  }, [onCloseClick]);\n  // Open info window after content container is set\n  useEffect(() => {\n    // anchor === null means an anchor is defined but not ready yet.\n    if (!contentContainer || !infoWindowRef.current || anchor === null) return;\n    const openOptions = {\n      map\n    };\n    if (anchor) {\n      openOptions.anchor = anchor;\n    }\n    if (shouldFocus !== undefined) {\n      openOptions.shouldFocus = shouldFocus;\n    }\n    infoWindowRef.current.open(openOptions);\n  }, [contentContainer, infoWindowRef, anchor, map, shouldFocus]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, contentContainer !== null && createPortal(children, contentContainer));\n};\nconst shownMessages = new Set();\nfunction logErrorOnce() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  const key = JSON.stringify(args);\n  if (!shownMessages.has(key)) {\n    shownMessages.add(key);\n    console.error(...args);\n  }\n}\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nconst useMap = function () {\n  let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n  const ctx = useContext(APIProviderContext);\n  const {\n    map\n  } = useContext(GoogleMapsContext) || {};\n  if (ctx === null) {\n    logErrorOnce('useMap(): failed to retrieve APIProviderContext. ' + 'Make sure that the <APIProvider> component exists and that the ' + 'component you are calling `useMap()` from is a sibling of the ' + '<APIProvider>.');\n    return null;\n  }\n  const {\n    mapInstances\n  } = ctx;\n  // if an id is specified, the corresponding map or null is returned\n  if (id !== null) return mapInstances[id] || null;\n  // otherwise, return the closest ancestor\n  if (map) return map;\n  // finally, return the default map instance\n  return mapInstances['default'] || null;\n};\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nconst ControlPosition = {\n  TOP_LEFT: 1,\n  TOP_CENTER: 2,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  LEFT_CENTER: 4,\n  LEFT_TOP: 5,\n  LEFT: 5,\n  LEFT_BOTTOM: 6,\n  RIGHT_TOP: 7,\n  RIGHT: 7,\n  RIGHT_CENTER: 8,\n  RIGHT_BOTTOM: 9,\n  BOTTOM_LEFT: 10,\n  BOTTOM_CENTER: 11,\n  BOTTOM: 11,\n  BOTTOM_RIGHT: 12,\n  CENTER: 13,\n  BLOCK_START_INLINE_START: 14,\n  BLOCK_START_INLINE_CENTER: 15,\n  BLOCK_START_INLINE_END: 16,\n  INLINE_START_BLOCK_CENTER: 17,\n  INLINE_START_BLOCK_START: 18,\n  INLINE_START_BLOCK_END: 19,\n  INLINE_END_BLOCK_START: 20,\n  INLINE_END_BLOCK_CENTER: 21,\n  INLINE_END_BLOCK_END: 22,\n  BLOCK_END_INLINE_START: 23,\n  BLOCK_END_INLINE_CENTER: 24,\n  BLOCK_END_INLINE_END: 25\n};\nconst MapControl = _ref2 => {\n  let {\n    children,\n    position\n  } = _ref2;\n  const controlContainer = useMemo(() => document.createElement('div'), []);\n  const map = useMap();\n  useEffect(() => {\n    if (!map) return;\n    const controls = map.controls[position];\n    controls.push(controlContainer);\n    return () => {\n      const controlsArray = controls.getArray();\n      // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n      if (!controlsArray) return;\n      const index = controlsArray.indexOf(controlContainer);\n      controls.removeAt(index);\n    };\n  }, [controlContainer, map, position]);\n  return createPortal(children, controlContainer);\n};\nconst _excluded = [\"onClick\", \"onDrag\", \"onDragStart\", \"onDragEnd\", \"onMouseOver\", \"onMouseOut\"];\nfunction useMarker(props) {\n  var _useContext;\n  const [marker, setMarker] = useState(null);\n  const map = (_useContext = useContext(GoogleMapsContext)) == null ? void 0 : _useContext.map;\n  const {\n      onClick,\n      onDrag,\n      onDragStart,\n      onDragEnd,\n      onMouseOver,\n      onMouseOut\n    } = props,\n    markerOptions = _objectWithoutPropertiesLoose(props, _excluded);\n  const {\n    position,\n    draggable\n  } = markerOptions;\n  // create marker instance and add to the map once the map is available\n  useEffect(() => {\n    if (!map) {\n      if (map === undefined) console.error('<Marker> has to be inside a Map component.');\n      return;\n    }\n    const newMarker = new google.maps.Marker(markerOptions);\n    newMarker.setMap(map);\n    setMarker(newMarker);\n    return () => {\n      newMarker.setMap(null);\n      setMarker(null);\n    };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map]);\n  // attach and re-attach event-handlers when any of the properties change\n  useEffect(() => {\n    if (!marker) return;\n    const m = marker;\n    // Add event listeners\n    const gme = google.maps.event;\n    if (onClick) gme.addListener(m, 'click', onClick);\n    if (onDrag) gme.addListener(m, 'drag', onDrag);\n    if (onDragStart) gme.addListener(m, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(m, 'dragend', onDragEnd);\n    if (onMouseOver) gme.addListener(m, 'mouseover', onMouseOver);\n    if (onMouseOut) gme.addListener(m, 'mouseout', onMouseOut);\n    marker.setDraggable(Boolean(draggable));\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDrag, onDragStart, onDragEnd, onMouseOver, onMouseOut]);\n  // update markerOptions (note the dependencies aren't properly checked\n  // here, we just assume that setOptions is smart enough to not waste a\n  // lot of time updating values that didn't change)\n  useEffect(() => {\n    if (!marker) return;\n    if (markerOptions) marker.setOptions(markerOptions);\n  }, [marker, markerOptions]);\n  // update position when changed\n  useEffect(() => {\n    // Should not update position when draggable\n    if (draggable || !position || !marker) return;\n    marker.setPosition(position);\n  }, [draggable, position, marker]);\n  return marker;\n}\n/**\n * Component to render a Google Maps Marker on a map\n */\nconst Marker = forwardRef((props, ref) => {\n  const marker = useMarker(props);\n  useImperativeHandle(ref, () => marker, [marker]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null);\n});\nfunction useMarkerRef() {\n  const [marker, setMarker] = useState(null);\n  const refCallback = useCallback(m => {\n    setMarker(m);\n  }, []);\n  return [refCallback, marker];\n}\n\n/**\n * Component to render a google maps marker Pin View\n */\nconst Pin = props => {\n  var _useContext;\n  const advancedMarker = (_useContext = useContext(AdvancedMarkerContext)) == null ? void 0 : _useContext.marker;\n  const glyphContainer = useMemo(() => document.createElement('div'), []);\n  // Create Pin View instance\n  useEffect(() => {\n    if (!advancedMarker) {\n      if (advancedMarker === undefined) {\n        console.error('The <Pin> component can only be used inside <AdvancedMarker>.');\n      }\n      return;\n    }\n    if (props.glyph && props.children) {\n      logErrorOnce('The <Pin> component only uses children to render the glyph if both the glyph property and children are present.');\n    }\n    if (Children.count(props.children) > 1) {\n      logErrorOnce('Passing multiple children to the <Pin> component might lead to unexpected results.');\n    }\n    const pinViewOptions = _extends({}, props);\n    const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n    // Set glyph to glyph container if children are present (rendered via portal).\n    // If both props.glyph and props.children are present, props.children takes priority.\n    if (props.children) {\n      pinElement.glyph = glyphContainer;\n    }\n    // Set content of Advanced Marker View to the Pin View element\n    advancedMarker.content = pinElement.element;\n  }, [advancedMarker, glyphContainer, props]);\n  return createPortal(props.children, glyphContainer);\n};\nconst mapLinear = (x, a1, a2, b1, b2) => b1 + (x - a1) * (b2 - b1) / (a2 - a1);\nconst getMapMaxTilt = zoom => {\n  if (zoom <= 10) {\n    return 30;\n  }\n  if (zoom >= 15.5) {\n    return 67.5;\n  }\n  // range [10...14]\n  if (zoom <= 14) {\n    return mapLinear(zoom, 10, 14, 30, 45);\n  }\n  // range [14...15.5]\n  return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst limitTiltRange = _ref3 => {\n  let {\n    viewState\n  } = _ref3;\n  const pitch = viewState.pitch;\n  const gmZoom = viewState.zoom + 1;\n  const maxTilt = getMapMaxTilt(gmZoom);\n  return _extends({}, viewState, {\n    fovy: 25,\n    pitch: Math.min(maxTilt, pitch)\n  });\n};\nexport { APILoadingStatus, APIProvider, APIProviderContext, AdvancedMarker, AdvancedMarkerContext, ControlPosition, GoogleMapsContext, InfoWindow, Map, MapControl, Marker, Pin, isLatLngLiteral, latLngEquals, limitTiltRange, toLatLngLiteral, useAdvancedMarkerRef, useApiIsLoaded, useApiLoadingStatus, useMap, useMapsLibrary, useMarkerRef };","map":{"version":3,"names":["APILoadingStatus","NOT_LOADED","LOADING","LOADED","FAILED","AUTH_FAILURE","MAPS_API_BASE_URL","GoogleMapsApiLoader","load","params","onLoadingStatusChange","_window$google","libraries","split","serializedParams","serializeParams","listeners","push","window","google","maps","importLibrary","serializedApiParams","loadingStatus","notifyLoadingStatusListeners","initImportLibrary","console","warn","librariesToLoad","Promise","all","map","name","v","key","language","region","authReferrerPolicy","solutionChannel","join","error","apiPromise","loadApi","resolve","reject","_document$querySelect","scriptElement","document","createElement","urlParams","URLSearchParams","value","Object","entries","urlParamName","replace","t","toLowerCase","set","async","src","toString","nonce","querySelector","onerror","Error","__googleMapsCallback__","gm_authFailure","head","append","libraryName","then","fn","APIProviderContext","React","createContext","useMapInstances","mapInstances","setMapInstances","useState","addMapInstance","mapInstance","id","arguments","length","undefined","instances","_extends","removeMapInstance","_ref","remaining","_objectWithoutPropertiesLoose","_toPropertyKey","clearMapInstances","useGoogleMapsApiLoader","props","onLoad","apiKey","version","otherApiParams","_excluded$3","status","setStatus","loadedLibraries","addLoadedLibrary","useReducer","action","librariesString","useMemo","JSON","stringify","useCallback","_google","res","useEffect","APIProvider","children","loaderProps","_excluded2","contextValue","Provider","useMapEvents","propName","eventPropNames","handler","eventType","propNameToEventType","listener","event","addListener","ev","createMapEvent","remove","type","srcEvent","detail","stoppable","stop","cameraEventTypes","includes","camEvent","center","getCenter","zoom","getZoom","heading","getHeading","tilt","getTilt","bounds","getBounds","Number","isFinite","toJSON","lat","lng","north","east","south","west","mouseEventTypes","_srcEvent$latLng","mouseEvent","domEvent","latLng","placeId","onBoundsChanged","onCenterChanged","onClick","onContextmenu","onDblclick","onDrag","onDragend","onDragstart","onHeadingChanged","onIdle","onIsFractionalZoomEnabledChanged","onMapCapabilitiesChanged","onMapTypeIdChanged","onMousemove","onMouseout","onMouseover","onProjectionChanged","onRenderingTypeChanged","onTilesLoaded","onTiltChanged","onZoomChanged","onCameraChanged","keys","useDeepCompareEffect","effect","deps","ref","useRef","current","isDeepEqual","mapOptionKeys","Set","useMapOptions","mapProps","mapOptions","has","setOptions","useApiLoadingStatus","_useContext","useContext","useDeckGLCameraUpdate","viewport","viewState","isDeckGlControlled","useLayoutEffect","latitude","longitude","bearing","pitch","moveCamera","isLatLngLiteral","obj","latLngEquals","a","b","A","toLatLngLiteral","B","useMapCameraParams","cameraStateRef","nextCamera","needsUpdate","AuthFailureMessage","style","position","top","left","bottom","right","zIndex","display","flexFlow","textAlign","justifyContent","fontSize","color","background","padding","useCallbackRef","el","setEl","useApiIsLoaded","useForceUpdate","forceUpdate","x","handleBoundsChange","assign","useTrackedCameraStateRef","useMapInstance","context","apiIsLoaded","setMap","container","containerRef","defaultBounds","defaultCenter","defaultZoom","defaultHeading","defaultTilt","_excluded$2","savedMapStateRef","mapId","newMap","Map","fitBounds","savedMapId","cameraState","savedCameraState","clearInstanceListeners","GoogleMapsContext","className","mapRef","isControlledExternally","controlled","disableDefaultUI","gestureHandling","keyboardShortcuts","cameraOptions","_lat","_lng","_props$zoom","_props$heading","_props$tilt","combinedStyle","width","height","deckGLViewProps","useMapsLibrary","ctx","AdvancedMarkerContext","useAdvancedMarker","marker","setMarker","contentContainer","setContentContainer","markerLibrary","onDragStart","onDragEnd","collisionBehavior","draggable","title","numChilds","Children","count","newMarker","AdvancedMarkerElement","content","gme","m","gmpDraggable","AdvancedMarker","forwardRef","advancedMarkerContextValue","useImperativeHandle","createPortal","useAdvancedMarkerRef","refCallback","InfoWindow","anchor","shouldFocus","onCloseClick","infoWindowOptions","_excluded$1","infoWindowRef","newInfowindow","setContent","close","_infoWindowRef$curren","openOptions","open","Fragment","shownMessages","logErrorOnce","_len","args","Array","_key","add","useMap","ControlPosition","TOP_LEFT","TOP_CENTER","TOP","TOP_RIGHT","LEFT_CENTER","LEFT_TOP","LEFT","LEFT_BOTTOM","RIGHT_TOP","RIGHT","RIGHT_CENTER","RIGHT_BOTTOM","BOTTOM_LEFT","BOTTOM_CENTER","BOTTOM","BOTTOM_RIGHT","CENTER","BLOCK_START_INLINE_START","BLOCK_START_INLINE_CENTER","BLOCK_START_INLINE_END","INLINE_START_BLOCK_CENTER","INLINE_START_BLOCK_START","INLINE_START_BLOCK_END","INLINE_END_BLOCK_START","INLINE_END_BLOCK_CENTER","INLINE_END_BLOCK_END","BLOCK_END_INLINE_START","BLOCK_END_INLINE_CENTER","BLOCK_END_INLINE_END","MapControl","_ref2","controlContainer","controls","controlsArray","getArray","index","indexOf","removeAt","useMarker","onMouseOver","onMouseOut","markerOptions","_excluded","Marker","setDraggable","Boolean","setPosition","useMarkerRef","Pin","advancedMarker","glyphContainer","glyph","pinViewOptions","pinElement","PinElement","element","mapLinear","a1","a2","b1","b2","getMapMaxTilt","limitTiltRange","_ref3","gmZoom","maxTilt","fovy","Math","min"],"sources":["/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/api-loading-status.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/google-maps-api-loader.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/api-provider.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/use-map-events.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/use-deep-compare-effect.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/use-map-options.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/hooks/use-api-loading-status.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/use-deckgl-camera-update.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/lat-lng-utils.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/use-map-camera-params.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/auth-failure-message.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/use-callback-ref.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/hooks/use-api-is-loaded.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/use-force-update.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/use-tracked-camera-state-ref.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/use-map-instance.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map/index.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/hooks/use-maps-library.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/advanced-marker.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/info-window.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/errors.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/hooks/use-map.ts","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/map-control.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/marker.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/components/pin.tsx","/home/gpt2008/Desktop/Clubs/club/club/club-ui/node_modules/@vis.gl/react-google-maps/src/libraries/limit-tilt-range.ts"],"sourcesContent":["export const APILoadingStatus = {\n  NOT_LOADED: 'NOT_LOADED',\n  LOADING: 'LOADING',\n  LOADED: 'LOADED',\n  FAILED: 'FAILED',\n  AUTH_FAILURE: 'AUTH_FAILURE'\n};\nexport type APILoadingStatus =\n  (typeof APILoadingStatus)[keyof typeof APILoadingStatus];\n","import {APILoadingStatus} from './api-loading-status';\n\nexport type ApiParams = {\n  key: string;\n  v?: string;\n  language?: string;\n  region?: string;\n  libraries?: string;\n  solutionChannel?: string;\n  authReferrerPolicy?: string;\n};\n\ntype LoadingStatusCallback = (status: APILoadingStatus) => void;\n\nconst MAPS_API_BASE_URL = 'https://maps.googleapis.com/maps/api/js';\n\n/**\n * A GoogleMapsApiLoader to reliably load and unload the Google Maps JavaScript API.\n *\n * The actual loading and unloading is delayed into the microtask queue, to\n * allow using the API in an useEffect hook, without worrying about multiple API loads.\n */\nexport class GoogleMapsApiLoader {\n  /**\n   * The current loadingStatus of the API.\n   */\n  public static loadingStatus: APILoadingStatus = APILoadingStatus.NOT_LOADED;\n\n  /**\n   * The parameters used for first loading the API.\n   */\n  public static serializedApiParams?: string;\n\n  /**\n   * A list of functions to be notified when the loading status changes.\n   */\n  private static listeners: LoadingStatusCallback[] = [];\n\n  /**\n   * Loads the Google Maps API with the specified parameters.\n   * Since the Maps library can only be loaded once per page, this will\n   * produce a warning when called multiple times with different\n   * parameters.\n   *\n   * The returned promise resolves when loading completes\n   * and rejects in case of an error or when the loading was aborted.\n   */\n  static async load(\n    params: ApiParams,\n    onLoadingStatusChange: (status: APILoadingStatus) => void\n  ): Promise<void> {\n    const libraries = params.libraries ? params.libraries.split(',') : [];\n    const serializedParams = this.serializeParams(params);\n\n    this.listeners.push(onLoadingStatusChange);\n\n    // Note: if `google.maps.importLibrary` has been defined externally, we\n    //   assume that loading is complete and successful.\n    //   If it was defined by a previous call to this method, a warning\n    //   message is logged if there are differences in api-parameters used\n    //   for both calls.\n\n    if (window.google?.maps?.importLibrary as unknown) {\n      // no serialized parameters means it was loaded externally\n      if (!this.serializedApiParams) {\n        this.loadingStatus = APILoadingStatus.LOADED;\n      }\n      this.notifyLoadingStatusListeners();\n    } else {\n      this.serializedApiParams = serializedParams;\n      this.initImportLibrary(params);\n    }\n\n    if (\n      this.serializedApiParams &&\n      this.serializedApiParams !== serializedParams\n    ) {\n      console.warn(\n        `[google-maps-api-loader] The maps API has already been loaded ` +\n          `with different parameters and will not be loaded again. Refresh the ` +\n          `page for new values to have effect.`\n      );\n    }\n\n    const librariesToLoad = ['maps', ...libraries];\n    await Promise.all(\n      librariesToLoad.map(name => google.maps.importLibrary(name))\n    );\n  }\n\n  /**\n   * Serialize the paramters used to load the library for easier comparison.\n   */\n  private static serializeParams(params: ApiParams): string {\n    return [\n      params.v,\n      params.key,\n      params.language,\n      params.region,\n      params.authReferrerPolicy,\n      params.solutionChannel\n    ].join('/');\n  }\n\n  /**\n   * Creates the global `google.maps.importLibrary` function for bootstrapping.\n   * This is essentially a formatted version of the dynamic loading script\n   * from the official documentation with some minor adjustments.\n   *\n   * The created importLibrary function will load the Google Maps JavaScript API,\n   * which will then replace the `google.maps.importLibrary` function with the full\n   * implementation.\n   *\n   * @see https://developers.google.com/maps/documentation/javascript/load-maps-js-api#dynamic-library-import\n   */\n  private static initImportLibrary(params: ApiParams) {\n    if (!window.google) window.google = {} as never;\n    if (!window.google.maps) window.google.maps = {} as never;\n\n    if (window.google.maps['importLibrary']) {\n      console.error(\n        '[google-maps-api-loader-internal]: initImportLibrary must only be called once'\n      );\n\n      return;\n    }\n\n    let apiPromise: Promise<void> | null = null;\n\n    const loadApi = () => {\n      if (apiPromise) return apiPromise;\n\n      apiPromise = new Promise((resolve, reject) => {\n        const scriptElement = document.createElement('script');\n        const urlParams = new URLSearchParams();\n\n        for (const [key, value] of Object.entries(params)) {\n          const urlParamName = key.replace(\n            /[A-Z]/g,\n            t => '_' + t[0].toLowerCase()\n          );\n          urlParams.set(urlParamName, value);\n        }\n        urlParams.set('loading', 'async');\n        urlParams.set('callback', '__googleMapsCallback__');\n\n        scriptElement.async = true;\n        scriptElement.src = MAPS_API_BASE_URL + `?` + urlParams.toString();\n        scriptElement.nonce =\n          (document.querySelector('script[nonce]') as HTMLScriptElement)\n            ?.nonce || '';\n\n        scriptElement.onerror = () => {\n          this.loadingStatus = APILoadingStatus.FAILED;\n          this.notifyLoadingStatusListeners();\n          reject(new Error('The Google Maps JavaScript API could not load.'));\n        };\n\n        window.__googleMapsCallback__ = () => {\n          this.loadingStatus = APILoadingStatus.LOADED;\n          this.notifyLoadingStatusListeners();\n          resolve();\n        };\n\n        window.gm_authFailure = () => {\n          this.loadingStatus = APILoadingStatus.AUTH_FAILURE;\n          this.notifyLoadingStatusListeners();\n        };\n\n        this.loadingStatus = APILoadingStatus.LOADING;\n        this.notifyLoadingStatusListeners();\n\n        document.head.append(scriptElement);\n      });\n\n      return apiPromise;\n    };\n\n    // for the first load, we declare an importLibrary function that will\n    // be overwritten once the api is loaded.\n    google.maps.importLibrary = libraryName =>\n      loadApi().then(() => google.maps.importLibrary(libraryName));\n  }\n\n  /**\n   * Calls all registered loadingStatusListeners after a status update.\n   */\n  private static notifyLoadingStatusListeners() {\n    for (const fn of this.listeners) {\n      fn(this.loadingStatus);\n    }\n  }\n}\n\n// Declare global maps callback functions\ndeclare global {\n  interface Window {\n    __googleMapsCallback__?: () => void;\n    gm_authFailure?: () => void;\n  }\n}\n","import React, {\n  PropsWithChildren,\n  ReactElement,\n  useCallback,\n  useEffect,\n  useMemo,\n  useReducer,\n  useState\n} from 'react';\n\nimport {\n  ApiParams,\n  GoogleMapsApiLoader\n} from '../libraries/google-maps-api-loader';\nimport {APILoadingStatus} from '../libraries/api-loading-status';\n\ntype ImportLibraryFunction = typeof google.maps.importLibrary;\ntype GoogleMapsLibrary = Awaited<ReturnType<ImportLibraryFunction>>;\ntype LoadedLibraries = {[name: string]: GoogleMapsLibrary};\n\nexport interface APIProviderContextValue {\n  status: APILoadingStatus;\n  loadedLibraries: LoadedLibraries;\n  importLibrary: typeof google.maps.importLibrary;\n  mapInstances: Record<string, google.maps.Map>;\n  addMapInstance: (map: google.maps.Map, id?: string) => void;\n  removeMapInstance: (id?: string) => void;\n  clearMapInstances: () => void;\n}\n\nexport const APIProviderContext =\n  React.createContext<APIProviderContextValue | null>(null);\n\nexport type APIProviderProps = {\n  /**\n   * apiKey must be provided to load the Google Maps JavaScript API. To create an API key, see: https://developers.google.com/maps/documentation/javascript/get-api-key\n   * Part of:\n   */\n  apiKey: string;\n  /**\n   * A custom id to reference the script tag can be provided. The default is set to 'google-maps-api'\n   * @default 'google-maps-api'\n   */\n  libraries?: Array<string>;\n  /**\n   * A specific version of the Google Maps JavaScript API can be used.\n   * Read more about versioning: https://developers.google.com/maps/documentation/javascript/versions\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  version?: string;\n  /**\n   * Sets the map to a specific region.\n   * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  region?: string;\n  /**\n   * Use a specific language for the map.\n   * Read more about localizing the Map: https://developers.google.com/maps/documentation/javascript/localization\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  language?: string;\n  /**\n   * auth_referrer_policy can be set to 'origin'.\n   * Part of: https://developers.google.com/maps/documentation/javascript/url-params\n   */\n  authReferrerPolicy?: string;\n  /**\n   * A function that can be used to execute code after the Google Maps JavaScript API has been loaded.\n   */\n  onLoad?: () => void;\n};\n\n/**\n * local hook to set up the map-instance management context.\n */\nfunction useMapInstances() {\n  const [mapInstances, setMapInstances] = useState<\n    Record<string, google.maps.Map>\n  >({});\n\n  const addMapInstance = (mapInstance: google.maps.Map, id = 'default') => {\n    setMapInstances(instances => ({...instances, [id]: mapInstance}));\n  };\n\n  const removeMapInstance = (id = 'default') => {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    setMapInstances(({[id]: _, ...remaining}) => remaining);\n  };\n\n  const clearMapInstances = () => {\n    setMapInstances({});\n  };\n\n  return {mapInstances, addMapInstance, removeMapInstance, clearMapInstances};\n}\n\n/**\n * local hook to handle the loading of the maps API, returns the current loading status\n * @param props\n */\nfunction useGoogleMapsApiLoader(props: APIProviderProps) {\n  const {onLoad, apiKey, version, libraries = [], ...otherApiParams} = props;\n\n  const [status, setStatus] = useState<APILoadingStatus>(\n    GoogleMapsApiLoader.loadingStatus\n  );\n  const [loadedLibraries, addLoadedLibrary] = useReducer(\n    (\n      loadedLibraries: LoadedLibraries,\n      action: {name: keyof LoadedLibraries; value: LoadedLibraries[string]}\n    ) => {\n      return {...loadedLibraries, [action.name]: action.value};\n    },\n    {}\n  );\n\n  const librariesString = useMemo(() => libraries?.join(','), [libraries]);\n  const serializedParams = useMemo(\n    () => JSON.stringify({apiKey, version, ...otherApiParams}),\n    [apiKey, version, otherApiParams]\n  );\n\n  const importLibrary: typeof google.maps.importLibrary = useCallback(\n    async (name: string) => {\n      if (loadedLibraries[name]) {\n        return loadedLibraries[name];\n      }\n\n      if (!google?.maps?.importLibrary) {\n        throw new Error(\n          '[api-provider-internal] importLibrary was called before ' +\n            'google.maps.importLibrary was defined.'\n        );\n      }\n\n      const res = await window.google.maps.importLibrary(name);\n      addLoadedLibrary({name, value: res});\n\n      return res;\n    },\n    [loadedLibraries]\n  );\n\n  useEffect(\n    () => {\n      (async () => {\n        try {\n          const params: ApiParams = {key: apiKey, ...otherApiParams};\n          if (version) params.v = version;\n          if (librariesString?.length > 0) params.libraries = librariesString;\n\n          await GoogleMapsApiLoader.load(params, status => setStatus(status));\n\n          for (const name of ['core', 'maps', ...libraries]) {\n            await importLibrary(name);\n          }\n\n          if (onLoad) {\n            onLoad();\n          }\n        } catch (error) {\n          console.error('<ApiProvider> failed to load Google Maps API', error);\n        }\n      })();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [apiKey, librariesString, serializedParams]\n  );\n\n  return {\n    status,\n    loadedLibraries,\n    importLibrary\n  };\n}\n\n/**\n * Component to wrap the Google Maps React components and load the Google Maps JavaScript API\n */\nexport const APIProvider = (\n  props: PropsWithChildren<APIProviderProps>\n): ReactElement | null => {\n  const {children, ...loaderProps} = props;\n  const {mapInstances, addMapInstance, removeMapInstance, clearMapInstances} =\n    useMapInstances();\n\n  const {status, loadedLibraries, importLibrary} =\n    useGoogleMapsApiLoader(loaderProps);\n\n  const contextValue: APIProviderContextValue = useMemo(\n    () => ({\n      mapInstances,\n      addMapInstance,\n      removeMapInstance,\n      clearMapInstances,\n      status,\n      loadedLibraries,\n      importLibrary\n    }),\n    [\n      mapInstances,\n      addMapInstance,\n      removeMapInstance,\n      clearMapInstances,\n      status,\n      loadedLibraries,\n      importLibrary\n    ]\n  );\n\n  return (\n    <APIProviderContext.Provider value={contextValue}>\n      {children}\n    </APIProviderContext.Provider>\n  );\n};\n","import {useEffect} from 'react';\n\n/**\n * Handlers for all events that could be emitted by map-instances.\n */\nexport type MapEventProps = Partial<{\n  // map view state events\n  onBoundsChanged: (event: MapCameraChangedEvent) => void;\n  onCenterChanged: (event: MapCameraChangedEvent) => void;\n  onHeadingChanged: (event: MapCameraChangedEvent) => void;\n  onTiltChanged: (event: MapCameraChangedEvent) => void;\n  onZoomChanged: (event: MapCameraChangedEvent) => void;\n  onProjectionChanged: (event: MapCameraChangedEvent) => void;\n  onCameraChanged: (event: MapCameraChangedEvent) => void;\n\n  // mouse / touch / pointer events\n  onClick: (event: MapMouseEvent) => void;\n  onDblclick: (event: MapMouseEvent) => void;\n  onContextmenu: (event: MapMouseEvent) => void;\n  onMousemove: (event: MapMouseEvent) => void;\n  onMouseover: (event: MapMouseEvent) => void;\n  onMouseout: (event: MapMouseEvent) => void;\n  onDrag: (event: MapEvent) => void;\n  onDragend: (event: MapEvent) => void;\n  onDragstart: (event: MapEvent) => void;\n\n  // loading events\n  onTilesLoaded: (event: MapEvent) => void;\n  onIdle: (event: MapEvent) => void;\n\n  // configuration events\n  onIsFractionalZoomEnabledChanged: (event: MapEvent) => void;\n  onMapCapabilitiesChanged: (event: MapEvent) => void;\n  onMapTypeIdChanged: (event: MapEvent) => void;\n  onRenderingTypeChanged: (event: MapEvent) => void;\n}>;\n\n/**\n * Sets up effects to bind event-handlers for all event-props in MapEventProps.\n * @internal\n */\nexport function useMapEvents(\n  map: google.maps.Map | null,\n  props: MapEventProps\n) {\n  // note: calling a useEffect hook from within a loop is prohibited by the\n  // rules of hooks, but it's ok here since it's unconditional and the number\n  // and order of iterations is always strictly the same.\n  // (see https://legacy.reactjs.org/docs/hooks-rules.html)\n\n  for (const propName of eventPropNames) {\n    // fixme: this cast is essentially a 'trust me, bro' for typescript, but\n    //   a proper solution seems way too complicated right now\n    const handler = props[propName] as (ev: MapEvent) => void;\n    const eventType = propNameToEventType[propName];\n\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    useEffect(() => {\n      if (!map) return;\n      if (!handler) return;\n\n      const listener = google.maps.event.addListener(\n        map,\n        eventType,\n        (ev?: google.maps.MapMouseEvent | google.maps.IconMouseEvent) => {\n          handler(createMapEvent(eventType, map, ev));\n        }\n      );\n\n      return () => listener.remove();\n    }, [map, eventType, handler]);\n  }\n}\n\n/**\n * Create the wrapped map-events used for the event-props.\n * @param type the event type as it is specified to the maps api\n * @param map the map instance the event originates from\n * @param srcEvent the source-event if there is one.\n */\nfunction createMapEvent(\n  type: string,\n  map: google.maps.Map,\n  srcEvent?: google.maps.MapMouseEvent | google.maps.IconMouseEvent\n): MapEvent {\n  const ev: MapEvent = {\n    type,\n    map,\n    detail: {},\n    stoppable: false,\n    stop: () => {}\n  };\n\n  if (cameraEventTypes.includes(type)) {\n    const camEvent = ev as MapCameraChangedEvent;\n\n    const center = map.getCenter();\n    const zoom = map.getZoom();\n    const heading = map.getHeading() || 0;\n    const tilt = map.getTilt() || 0;\n    const bounds = map.getBounds();\n\n    if (!center || !bounds || !Number.isFinite(zoom)) {\n      console.warn(\n        '[createEvent] at least one of the values from the map ' +\n          'returned undefined. This is not expected to happen. Please ' +\n          'report an issue at https://github.com/visgl/react-google-maps/issues/new'\n      );\n    }\n\n    camEvent.detail = {\n      center: center?.toJSON() || {lat: 0, lng: 0},\n      zoom: (zoom as number) || 0,\n      heading: heading as number,\n      tilt: tilt as number,\n      bounds: bounds?.toJSON() || {\n        north: 90,\n        east: 180,\n        south: -90,\n        west: -180\n      }\n    };\n\n    return camEvent;\n  } else if (mouseEventTypes.includes(type)) {\n    if (!srcEvent)\n      throw new Error('[createEvent] mouse events must provide a srcEvent');\n    const mouseEvent = ev as MapMouseEvent;\n\n    mouseEvent.domEvent = srcEvent.domEvent;\n    mouseEvent.stoppable = true;\n    mouseEvent.stop = () => srcEvent.stop();\n\n    mouseEvent.detail = {\n      latLng: srcEvent.latLng?.toJSON() || null,\n      placeId: (srcEvent as google.maps.IconMouseEvent).placeId\n    };\n\n    return mouseEvent;\n  }\n\n  return ev;\n}\n\n/**\n * maps the camelCased names of event-props to the corresponding event-types\n * used in the maps API.\n */\nconst propNameToEventType: {[prop in keyof Required<MapEventProps>]: string} = {\n  onBoundsChanged: 'bounds_changed',\n  onCenterChanged: 'center_changed',\n  onClick: 'click',\n  onContextmenu: 'contextmenu',\n  onDblclick: 'dblclick',\n  onDrag: 'drag',\n  onDragend: 'dragend',\n  onDragstart: 'dragstart',\n  onHeadingChanged: 'heading_changed',\n  onIdle: 'idle',\n  onIsFractionalZoomEnabledChanged: 'isfractionalzoomenabled_changed',\n  onMapCapabilitiesChanged: 'mapcapabilities_changed',\n  onMapTypeIdChanged: 'maptypeid_changed',\n  onMousemove: 'mousemove',\n  onMouseout: 'mouseout',\n  onMouseover: 'mouseover',\n  onProjectionChanged: 'projection_changed',\n  onRenderingTypeChanged: 'renderingtype_changed',\n  onTilesLoaded: 'tilesloaded',\n  onTiltChanged: 'tilt_changed',\n  onZoomChanged: 'zoom_changed',\n\n  // note: onCameraChanged is an alias for the bounds_changed event,\n  // since that is going to be fired in every situation where the camera is\n  // updated.\n  onCameraChanged: 'bounds_changed'\n} as const;\n\nconst cameraEventTypes = [\n  'bounds_changed',\n  'center_changed',\n  'heading_changed',\n  'projection_changed',\n  'tilt_changed',\n  'zoom_changed'\n];\n\nconst mouseEventTypes = [\n  'click',\n  'contextmenu',\n  'dblclick',\n  'mousemove',\n  'mouseout',\n  'mouseover'\n];\n\ntype MapEventPropName = keyof MapEventProps;\nconst eventPropNames = Object.keys(propNameToEventType) as MapEventPropName[];\n\nexport type MapEvent<T = unknown> = {\n  type: string;\n  map: google.maps.Map;\n  detail: T;\n\n  stoppable: boolean;\n  stop: () => void;\n  domEvent?: MouseEvent | TouchEvent | PointerEvent | KeyboardEvent | Event;\n};\n\nexport type MapMouseEvent = MapEvent<{\n  latLng: google.maps.LatLngLiteral | null;\n  placeId: string | null;\n}>;\n\nexport type MapCameraChangedEvent = MapEvent<{\n  center: google.maps.LatLngLiteral;\n  bounds: google.maps.LatLngBoundsLiteral;\n  zoom: number;\n  heading: number;\n  tilt: number;\n}>;\n","import {DependencyList, EffectCallback, useEffect, useRef} from 'react';\nimport isDeepEqual from 'fast-deep-equal';\n\nexport function useDeepCompareEffect(\n  effect: EffectCallback,\n  deps: DependencyList\n) {\n  const ref = useRef<DependencyList | undefined>(undefined);\n\n  if (!ref.current || !isDeepEqual(deps, ref.current)) {\n    ref.current = deps;\n  }\n\n  // eslint-disable-next-line react-hooks/exhaustive-deps\n  useEffect(effect, ref.current);\n}\n","import {MapProps} from '../map';\nimport {useDeepCompareEffect} from '../../libraries/use-deep-compare-effect';\n\nconst mapOptionKeys = new Set([\n  'backgroundColor',\n  'clickableIcons',\n  'controlSize',\n  'disableDefaultUI',\n  'disableDoubleClickZoom',\n  'draggable',\n  'draggableCursor',\n  'draggingCursor',\n  'fullscreenControl',\n  'fullscreenControlOptions',\n  'gestureHandling',\n  'isFractionalZoomEnabled',\n  'keyboardShortcuts',\n  'mapTypeControl',\n  'mapTypeControlOptions',\n  'mapTypeId',\n  'maxZoom',\n  'minZoom',\n  'noClear',\n  'panControl',\n  'panControlOptions',\n  'restriction',\n  'rotateControl',\n  'rotateControlOptions',\n  'scaleControl',\n  'scaleControlOptions',\n  'scrollwheel',\n  'streetView',\n  'streetViewControl',\n  'streetViewControlOptions',\n  'styles',\n  'zoomControl',\n  'zoomControlOptions'\n]);\n\n/**\n * Internal hook to update the map-options when props are changed.\n *\n * @param map the map instance\n * @param mapProps the props to update the map-instance with\n * @internal\n */\nexport function useMapOptions(map: google.maps.Map | null, mapProps: MapProps) {\n  /* eslint-disable react-hooks/exhaustive-deps --\n   *\n   * The following effects aren't triggered when the map is changed.\n   * In that case, the values will be or have been passed to the map\n   * constructor via mapOptions.\n   */\n\n  const mapOptions: google.maps.MapOptions = {};\n  const keys = Object.keys(mapProps) as (keyof google.maps.MapOptions)[];\n  for (const key of keys) {\n    if (!mapOptionKeys.has(key)) continue;\n\n    mapOptions[key] = mapProps[key] as never;\n  }\n\n  // update the map options when mapOptions is changed\n  // Note: due to the destructuring above, mapOptions will be seen as changed\n  //   with every re-render, so we're assuming the maps-api will properly\n  //   deal with unchanged option-values passed into setOptions.\n  useDeepCompareEffect(() => {\n    if (!map) return;\n\n    map.setOptions(mapOptions);\n  }, [mapOptions]);\n  /* eslint-enable react-hooks/exhaustive-deps */\n}\n","import {useContext} from 'react';\nimport {APIProviderContext} from '../components/api-provider';\nimport {APILoadingStatus} from '../libraries/api-loading-status';\n\nexport function useApiLoadingStatus(): APILoadingStatus {\n  return useContext(APIProviderContext)?.status || APILoadingStatus.NOT_LOADED;\n}\n","import {useLayoutEffect} from 'react';\n\nexport type DeckGlCompatProps = {\n  /**\n   * Viewport from deck.gl\n   */\n  viewport?: unknown;\n  /**\n   * View state from deck.gl\n   */\n  viewState?: Record<string, unknown>;\n  /**\n   * Initial View State from deck.gl\n   */\n  initialViewState?: Record<string, unknown>;\n};\n\n/**\n * Internal hook that updates the camera when deck.gl viewState changes.\n * @internal\n */\nexport function useDeckGLCameraUpdate(\n  map: google.maps.Map | null,\n  props: DeckGlCompatProps\n) {\n  const {viewport, viewState} = props;\n  const isDeckGlControlled = !!viewport;\n\n  useLayoutEffect(() => {\n    if (!map || !viewState) return;\n\n    const {\n      latitude,\n      longitude,\n      bearing: heading,\n      pitch: tilt,\n      zoom\n    } = viewState as Record<string, number>;\n\n    map.moveCamera({\n      center: {lat: latitude, lng: longitude},\n      heading,\n      tilt,\n      zoom: zoom + 1\n    });\n  }, [map, viewState]);\n\n  return isDeckGlControlled;\n}\n","export function isLatLngLiteral(\n  obj: unknown\n): obj is google.maps.LatLngLiteral {\n  if (!obj || typeof obj !== 'object') return false;\n  if (!('lat' in obj && 'lng' in obj)) return false;\n\n  return Number.isFinite(obj.lat) && Number.isFinite(obj.lng);\n}\n\nexport function latLngEquals(\n  a: google.maps.LatLngLiteral | google.maps.LatLng | undefined | null,\n  b: google.maps.LatLngLiteral | google.maps.LatLng | undefined | null\n): boolean {\n  if (!a || !b) return false;\n  const A = toLatLngLiteral(a);\n  const B = toLatLngLiteral(b);\n  if (A.lat !== B.lat || A.lng !== B.lng) return false;\n  return true;\n}\n\nexport function toLatLngLiteral(\n  obj: google.maps.LatLngLiteral | google.maps.LatLng\n): google.maps.LatLngLiteral {\n  if (isLatLngLiteral(obj)) return obj;\n\n  return obj.toJSON();\n}\n","import {useLayoutEffect} from 'react';\nimport {CameraStateRef} from './use-tracked-camera-state-ref';\nimport {toLatLngLiteral} from '../../libraries/lat-lng-utils';\nimport {MapProps} from '../map';\n\nexport function useMapCameraParams(\n  map: google.maps.Map | null,\n  cameraStateRef: CameraStateRef,\n  mapProps: MapProps\n) {\n  const center = mapProps.center ? toLatLngLiteral(mapProps.center) : null;\n\n  let lat: number | null = null;\n  let lng: number | null = null;\n\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat as number;\n    lng = center.lng as number;\n  }\n\n  const zoom: number | null = Number.isFinite(mapProps.zoom)\n    ? (mapProps.zoom as number)\n    : null;\n  const heading: number | null = Number.isFinite(mapProps.heading)\n    ? (mapProps.heading as number)\n    : null;\n  const tilt: number | null = Number.isFinite(mapProps.tilt)\n    ? (mapProps.tilt as number)\n    : null;\n\n  // the following effect runs for every render of the map component and checks\n  // if there are differences between the known state of the map instance\n  // (cameraStateRef, which is updated by all bounds_changed events) and the\n  // desired state in the props.\n\n  useLayoutEffect(() => {\n    if (!map) return;\n\n    const nextCamera: google.maps.CameraOptions = {};\n    let needsUpdate = false;\n\n    if (\n      lat !== null &&\n      lng !== null &&\n      (cameraStateRef.current.center.lat !== lat ||\n        cameraStateRef.current.center.lng !== lng)\n    ) {\n      nextCamera.center = {lat, lng};\n      needsUpdate = true;\n    }\n\n    if (zoom !== null && cameraStateRef.current.zoom !== zoom) {\n      nextCamera.zoom = zoom as number;\n      needsUpdate = true;\n    }\n\n    if (heading !== null && cameraStateRef.current.heading !== heading) {\n      nextCamera.heading = heading as number;\n      needsUpdate = true;\n    }\n\n    if (tilt !== null && cameraStateRef.current.tilt !== tilt) {\n      nextCamera.tilt = tilt as number;\n      needsUpdate = true;\n    }\n\n    if (needsUpdate) {\n      map.moveCamera(nextCamera);\n    }\n  });\n}\n","import React, {CSSProperties} from 'react';\n\nexport const AuthFailureMessage = () => {\n  const style: CSSProperties = {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    bottom: 0,\n    right: 0,\n    zIndex: 999,\n    display: 'flex',\n    flexFlow: 'column nowrap',\n    textAlign: 'center',\n    justifyContent: 'center',\n    fontSize: '.8rem',\n    color: 'rgba(0,0,0,0.6)',\n    background: '#dddddd',\n    padding: '1rem 1.5rem'\n  };\n\n  return (\n    <div style={style}>\n      <h2>Error: AuthFailure</h2>\n      <p>\n        A problem with your API key prevents the map from rendering correctly.\n        Please make sure the value of the <code>APIProvider.apiKey</code> prop\n        is correct. Check the error-message in the console for further details.\n      </p>\n    </div>\n  );\n};\n","import {Ref, useCallback, useState} from 'react';\n\nexport function useCallbackRef<T>() {\n  const [el, setEl] = useState<T | null>(null);\n  const ref = useCallback((value: T) => setEl(value), [setEl]);\n\n  return [el, ref as Ref<T>] as const;\n}\n","import {useApiLoadingStatus} from './use-api-loading-status';\nimport {APILoadingStatus} from '../libraries/api-loading-status';\n/**\n * Hook to check if the Google Maps API is loaded\n */\nexport function useApiIsLoaded(): boolean {\n  const status = useApiLoadingStatus();\n\n  return status === APILoadingStatus.LOADED;\n}\n","import {useReducer} from 'react';\n\nexport function useForceUpdate(): () => void {\n  const [, forceUpdate] = useReducer(x => x + 1, 0);\n\n  return forceUpdate;\n}\n","import {MutableRefObject, useEffect, useRef} from 'react';\nimport {useForceUpdate} from '../../libraries/use-force-update';\n\nexport type CameraState = {\n  center: google.maps.LatLngLiteral;\n  heading: number;\n  tilt: number;\n  zoom: number;\n};\n\nexport type CameraStateRef = MutableRefObject<CameraState>;\n\nfunction handleBoundsChange(map: google.maps.Map, ref: CameraStateRef) {\n  const center = map.getCenter();\n  const zoom = map.getZoom();\n  const heading = map.getHeading() || 0;\n  const tilt = map.getTilt() || 0;\n  const bounds = map.getBounds();\n\n  if (!center || !bounds || !Number.isFinite(zoom)) {\n    console.warn(\n      '[useTrackedCameraState] at least one of the values from the map ' +\n        'returned undefined. This is not expected to happen. Please ' +\n        'report an issue at https://github.com/visgl/react-google-maps/issues/new'\n    );\n  }\n\n  // fixme: do we need the `undefined` cases for the camera-params? When are they used in the maps API?\n  Object.assign(ref.current, {\n    center: center?.toJSON() || {lat: 0, lng: 0},\n    zoom: (zoom as number) || 0,\n    heading: heading as number,\n    tilt: tilt as number\n  });\n}\n\n/**\n * Creates a mutable ref object to track the last known state of the map camera.\n * This is used in `useMapCameraParams` to reduce stuttering in normal operation\n * by avoiding updates of the map camera with values that have already been processed.\n */\nexport function useTrackedCameraStateRef(\n  map: google.maps.Map | null\n): CameraStateRef {\n  const forceUpdate = useForceUpdate();\n  const ref = useRef<CameraState>({\n    center: {lat: 0, lng: 0},\n    heading: 0,\n    tilt: 0,\n    zoom: 0\n  });\n\n  // Record camera state with every bounds_changed event dispatched by the map.\n  // This data is used to prevent feeding these values back to the\n  // map-instance when a typical \"controlled component\" setup (state variable is\n  // fed into and updated by the map).\n  useEffect(() => {\n    if (!map) return;\n\n    const listener = google.maps.event.addListener(\n      map,\n      'bounds_changed',\n      () => {\n        handleBoundsChange(map, ref);\n\n        // When an event is occured, we have to update during the next cycle.\n        // The application could decide to ignore the event and not update any\n        // camera props of the map, meaning that in that case we will have to\n        // 'undo' the change to the camera.\n        forceUpdate();\n      }\n    );\n\n    return () => listener.remove();\n  }, [map, forceUpdate]);\n\n  return ref;\n}\n","import {Ref, useEffect, useRef, useState} from 'react';\n\nimport {MapProps} from '../map';\nimport {APIProviderContextValue} from '../api-provider';\n\nimport {useCallbackRef} from '../../libraries/use-callback-ref';\nimport {useApiIsLoaded} from '../../hooks/use-api-is-loaded';\nimport {\n  CameraState,\n  CameraStateRef,\n  useTrackedCameraStateRef\n} from './use-tracked-camera-state-ref';\n\n/**\n * The main hook takes care of creating map-instances and registering them in\n * the api-provider context.\n * @return a tuple of the map-instance created (or null) and the callback\n *   ref that will be used to pass the map-container into this hook.\n * @internal\n */\nexport function useMapInstance(\n  props: MapProps,\n  context: APIProviderContextValue\n): readonly [\n  map: google.maps.Map | null,\n  containerRef: Ref<HTMLDivElement>,\n  cameraStateRef: CameraStateRef\n] {\n  const apiIsLoaded = useApiIsLoaded();\n  const [map, setMap] = useState<google.maps.Map | null>(null);\n  const [container, containerRef] = useCallbackRef<HTMLDivElement>();\n\n  const cameraStateRef = useTrackedCameraStateRef(map);\n\n  const {\n    id,\n    defaultBounds,\n    defaultCenter,\n    defaultZoom,\n    defaultHeading,\n    defaultTilt,\n\n    ...mapOptions\n  } = props;\n\n  // apply default camera props if available and not overwritten by controlled props\n  if (!mapOptions.center && defaultCenter) mapOptions.center = defaultCenter;\n  if (!mapOptions.zoom && Number.isFinite(defaultZoom))\n    mapOptions.zoom = defaultZoom;\n  if (!mapOptions.heading && Number.isFinite(defaultHeading))\n    mapOptions.heading = defaultHeading;\n  if (!mapOptions.tilt && Number.isFinite(defaultTilt))\n    mapOptions.tilt = defaultTilt;\n\n  for (const key of Object.keys(mapOptions) as (keyof typeof mapOptions)[])\n    if (mapOptions[key] === undefined) delete mapOptions[key];\n\n  const savedMapStateRef = useRef<{\n    mapId?: string | null;\n    cameraState: CameraState;\n  }>();\n\n  // create the map instance and register it in the context\n  useEffect(\n    () => {\n      if (!container || !apiIsLoaded) return;\n\n      const {addMapInstance, removeMapInstance} = context;\n      const mapId = props.mapId;\n      const newMap = new google.maps.Map(container, mapOptions);\n\n      setMap(newMap);\n      addMapInstance(newMap, id);\n\n      if (defaultBounds) {\n        newMap.fitBounds(defaultBounds);\n      }\n\n      // the savedMapState is used to restore the camera parameters when the mapId is changed\n      if (savedMapStateRef.current) {\n        const {mapId: savedMapId, cameraState: savedCameraState} =\n          savedMapStateRef.current;\n        if (savedMapId !== mapId) {\n          newMap.setOptions(savedCameraState);\n        }\n      }\n\n      return () => {\n        savedMapStateRef.current = {\n          mapId,\n          // eslint-disable-next-line react-hooks/exhaustive-deps\n          cameraState: cameraStateRef.current\n        };\n\n        // remove all event-listeners to minimize memory-leaks\n        google.maps.event.clearInstanceListeners(newMap);\n\n        setMap(null);\n        removeMapInstance(id);\n      };\n    },\n\n    // some dependencies are ignored in the list below:\n    //  - defaultBounds and the default* camera props will only be used once, and\n    //    changes should be ignored\n    //  - mapOptions has special hooks that take care of updating the options\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [container, apiIsLoaded, id, props.mapId]\n  );\n\n  return [map, containerRef, cameraStateRef] as const;\n}\n","/* eslint-disable complexity */\nimport React, {\n  CSSProperties,\n  PropsWithChildren,\n  useContext,\n  useEffect,\n  useLayoutEffect,\n  useMemo\n} from 'react';\n\nimport {APIProviderContext} from '../api-provider';\n\nimport {MapEventProps, useMapEvents} from './use-map-events';\nimport {useMapOptions} from './use-map-options';\nimport {useApiLoadingStatus} from '../../hooks/use-api-loading-status';\nimport {APILoadingStatus} from '../../libraries/api-loading-status';\nimport {\n  DeckGlCompatProps,\n  useDeckGLCameraUpdate\n} from './use-deckgl-camera-update';\nimport {toLatLngLiteral} from '../../libraries/lat-lng-utils';\nimport {useMapCameraParams} from './use-map-camera-params';\nimport {AuthFailureMessage} from './auth-failure-message';\nimport {useMapInstance} from './use-map-instance';\n\nexport interface GoogleMapsContextValue {\n  map: google.maps.Map | null;\n}\nexport const GoogleMapsContext =\n  React.createContext<GoogleMapsContextValue | null>(null);\n\nexport type {\n  MapCameraChangedEvent,\n  MapEvent,\n  MapEventProps,\n  MapMouseEvent\n} from './use-map-events';\n\nexport type MapCameraProps = {\n  center: google.maps.LatLngLiteral;\n  zoom: number;\n  heading?: number;\n  tilt?: number;\n};\n\n/**\n * Props for the Google Maps Map Component\n */\nexport type MapProps = google.maps.MapOptions &\n  MapEventProps &\n  DeckGlCompatProps & {\n    /**\n     * An id for the map, this is required when multiple maps are present\n     * in the same APIProvider context.\n     */\n    id?: string;\n    /**\n     * Additional style rules to apply to the map dom-element.\n     */\n    style?: CSSProperties;\n    /**\n     * Additional css class-name to apply to the element containing the map.\n     */\n    className?: string;\n    /**\n     * Indicates that the map will be controlled externally. Disables all controls provided by the map itself.\n     */\n    controlled?: boolean;\n\n    defaultCenter?: google.maps.LatLngLiteral;\n    defaultZoom?: number;\n    defaultHeading?: number;\n    defaultTilt?: number;\n    /**\n     * Alternative way to specify the default camera props as a geographic region that should be fully visible\n     */\n    defaultBounds?: google.maps.LatLngBoundsLiteral;\n  };\n\nexport const Map = (props: PropsWithChildren<MapProps>) => {\n  const {children, id, className, style} = props;\n  const context = useContext(APIProviderContext);\n  const loadingStatus = useApiLoadingStatus();\n\n  if (!context) {\n    throw new Error(\n      '<Map> can only be used inside an <ApiProvider> component.'\n    );\n  }\n\n  const [map, mapRef, cameraStateRef] = useMapInstance(props, context);\n\n  useMapCameraParams(map, cameraStateRef, props);\n  useMapEvents(map, props);\n  useMapOptions(map, props);\n\n  const isDeckGlControlled = useDeckGLCameraUpdate(map, props);\n  const isControlledExternally = !!props.controlled;\n\n  // disable interactions with the map for externally controlled maps\n  useEffect(() => {\n    if (!map) return;\n\n    // fixme: this doesn't seem to belong here (and it's mostly there for convenience anyway).\n    //   The reasoning is that a deck.gl canvas will be put on top of the map, rendering\n    //   any default map controls pretty much useless\n    if (isDeckGlControlled) {\n      map.setOptions({disableDefaultUI: true});\n    }\n\n    // disable all control-inputs when the map is controlled externally\n    if (isDeckGlControlled || isControlledExternally) {\n      map.setOptions({\n        gestureHandling: 'none',\n        keyboardShortcuts: false\n      });\n    }\n\n    return () => {\n      map.setOptions({\n        gestureHandling: props.gestureHandling,\n        keyboardShortcuts: props.keyboardShortcuts\n      });\n    };\n  }, [\n    map,\n    isDeckGlControlled,\n    isControlledExternally,\n    props.gestureHandling,\n    props.keyboardShortcuts\n  ]);\n\n  // setup a stable cameraOptions object that can be used as dependency\n  const center = props.center ? toLatLngLiteral(props.center) : null;\n  let lat: number | null = null;\n  let lng: number | null = null;\n  if (center && Number.isFinite(center.lat) && Number.isFinite(center.lng)) {\n    lat = center.lat as number;\n    lng = center.lng as number;\n  }\n\n  const cameraOptions: google.maps.CameraOptions = useMemo(() => {\n    return {\n      center: {lat: lat ?? 0, lng: lng ?? 0},\n      zoom: props.zoom ?? 0,\n      heading: props.heading ?? 0,\n      tilt: props.tilt ?? 0\n    };\n  }, [lat, lng, props.zoom, props.heading, props.tilt]);\n\n  // externally controlled mode: reject all camera changes that don't correspond to changes in props\n  useLayoutEffect(() => {\n    if (!map || !isControlledExternally) return;\n\n    map.moveCamera(cameraOptions);\n    const listener = map.addListener('bounds_changed', () => {\n      map.moveCamera(cameraOptions);\n    });\n\n    return () => listener.remove();\n  }, [map, isControlledExternally, cameraOptions]);\n\n  const combinedStyle: CSSProperties = useMemo(\n    () => ({\n      width: '100%',\n      height: '100%',\n      // when using deckgl, the map should be sent to the back\n      zIndex: isDeckGlControlled ? -1 : 0,\n\n      ...style\n    }),\n    [style, isDeckGlControlled]\n  );\n\n  const contextValue: GoogleMapsContextValue = useMemo(() => ({map}), [map]);\n\n  if (loadingStatus === APILoadingStatus.AUTH_FAILURE) {\n    return (\n      <div\n        style={{position: 'relative', ...(className ? {} : combinedStyle)}}\n        className={className}>\n        <AuthFailureMessage />\n      </div>\n    );\n  }\n\n  return (\n    <div\n      ref={mapRef}\n      data-testid={'map'}\n      style={className ? undefined : combinedStyle}\n      className={className}\n      {...(id ? {id} : {})}>\n      {map ? (\n        <GoogleMapsContext.Provider value={contextValue}>\n          {children}\n        </GoogleMapsContext.Provider>\n      ) : null}\n    </div>\n  );\n};\nMap.deckGLViewProps = true;\n","import {useContext, useEffect} from 'react';\n\nimport {APIProviderContext} from '../components/api-provider';\nimport {useApiIsLoaded} from './use-api-is-loaded';\n\ninterface ApiLibraries {\n  core: google.maps.CoreLibrary;\n  maps: google.maps.MapsLibrary;\n  places: google.maps.PlacesLibrary;\n  geocoding: google.maps.GeocodingLibrary;\n  routes: google.maps.RoutesLibrary;\n  marker: google.maps.MarkerLibrary;\n  geometry: google.maps.GeometryLibrary;\n  elevation: google.maps.ElevationLibrary;\n  streetView: google.maps.StreetViewLibrary;\n  journeySharing: google.maps.JourneySharingLibrary;\n  drawing: google.maps.DrawingLibrary;\n  visualization: google.maps.VisualizationLibrary;\n}\n\nexport function useMapsLibrary<\n  K extends keyof ApiLibraries,\n  V extends ApiLibraries[K]\n>(name: K): V | null;\n\nexport function useMapsLibrary(name: string) {\n  const apiIsLoaded = useApiIsLoaded();\n  const ctx = useContext(APIProviderContext);\n\n  useEffect(() => {\n    if (!apiIsLoaded || !ctx) return;\n\n    // Trigger loading the libraries via our proxy-method.\n    // The returned promise is ignored, since importLibrary will update loadedLibraries\n    // list in the context, triggering a re-render.\n    void ctx.importLibrary(name);\n  }, [apiIsLoaded, ctx, name]);\n\n  return ctx?.loadedLibraries[name] || null;\n}\n","/* eslint-disable complexity */\nimport React, {\n  Children,\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useMemo,\n  useState\n} from 'react';\n\nimport {createPortal} from 'react-dom';\nimport {GoogleMapsContext} from './map';\n\nimport type {Ref, PropsWithChildren} from 'react';\nimport {useMapsLibrary} from '../hooks/use-maps-library';\n\nexport interface AdvancedMarkerContextValue {\n  marker: google.maps.marker.AdvancedMarkerElement;\n}\n\nexport const AdvancedMarkerContext =\n  React.createContext<AdvancedMarkerContextValue | null>(null);\n\ntype AdvancedMarkerEventProps = {\n  onClick?: (e: google.maps.MapMouseEvent) => void;\n  onDrag?: (e: google.maps.MapMouseEvent) => void;\n  onDragStart?: (e: google.maps.MapMouseEvent) => void;\n  onDragEnd?: (e: google.maps.MapMouseEvent) => void;\n};\n\nexport type AdvancedMarkerProps = PropsWithChildren<\n  Omit<google.maps.marker.AdvancedMarkerElementOptions, 'gmpDraggable'> &\n    AdvancedMarkerEventProps & {\n      /**\n       * className to add a class to the advanced marker element\n       * Can only be used with HTML Marker content\n       */\n      className?: string;\n      draggable?: boolean;\n    }\n>;\n\nexport type AdvancedMarkerRef = google.maps.marker.AdvancedMarkerElement | null;\nfunction useAdvancedMarker(props: AdvancedMarkerProps) {\n  const [marker, setMarker] =\n    useState<google.maps.marker.AdvancedMarkerElement | null>(null);\n  const [contentContainer, setContentContainer] =\n    useState<HTMLDivElement | null>(null);\n\n  const map = useContext(GoogleMapsContext)?.map;\n  const markerLibrary = useMapsLibrary('marker');\n\n  const {\n    children,\n    className,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    collisionBehavior,\n    draggable,\n    position,\n    title,\n    zIndex\n  } = props;\n\n  const numChilds = Children.count(children);\n\n  // create marker instance and add it to the map when map becomes available\n  useEffect(() => {\n    if (!map || !markerLibrary) return;\n\n    const newMarker = new markerLibrary.AdvancedMarkerElement();\n    newMarker.map = map;\n\n    setMarker(newMarker);\n\n    // create container for marker content if there are children\n    if (numChilds > 0) {\n      const el = document.createElement('div');\n      if (className) el.className = className;\n\n      newMarker.content = el;\n\n      setContentContainer(el);\n    }\n\n    return () => {\n      newMarker.map = null;\n      setMarker(null);\n      setContentContainer(null);\n    };\n    // We do not want to re-render the whole marker when the className changes\n    // because that causes a short flickering of the marker.\n    // The className update is handled in the useEffect below.\n    // Excluding the className from the dependency array onm purpose here\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map, markerLibrary, numChilds]);\n\n  // update className of advanced marker element\n  useEffect(() => {\n    if (!contentContainer) return;\n    contentContainer.className = className ?? '';\n  }, [contentContainer, className]);\n\n  // bind all marker events\n  useEffect(() => {\n    if (!marker) return;\n\n    const gme = google.maps.event;\n\n    if (onClick) gme.addListener(marker, 'click', onClick);\n    if (onDrag) gme.addListener(marker, 'drag', onDrag);\n    if (onDragStart) gme.addListener(marker, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(marker, 'dragend', onDragEnd);\n\n    if ((onDrag || onDragStart || onDragEnd) && !draggable) {\n      console.warn(\n        'You need to set the marker to draggable to listen to drag-events.'\n      );\n    }\n\n    const m = marker;\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [marker, draggable, onClick, onDragStart, onDrag, onDragEnd]);\n\n  // update other marker props when changed\n  useEffect(() => {\n    if (!marker) return;\n\n    if (position !== undefined) marker.position = position;\n    if (draggable !== undefined) marker.gmpDraggable = draggable;\n    if (collisionBehavior !== undefined)\n      marker.collisionBehavior = collisionBehavior;\n    if (zIndex !== undefined) marker.zIndex = zIndex;\n    if (typeof title === 'string') marker.title = title;\n  }, [marker, position, draggable, collisionBehavior, zIndex, title]);\n\n  return [marker, contentContainer] as const;\n}\n\nexport const AdvancedMarker = forwardRef(\n  (props: AdvancedMarkerProps, ref: Ref<AdvancedMarkerRef>) => {\n    const {children} = props;\n    const [marker, contentContainer] = useAdvancedMarker(props);\n\n    const advancedMarkerContextValue: AdvancedMarkerContextValue | null =\n      useMemo(() => (marker ? {marker} : null), [marker]);\n\n    useImperativeHandle(ref, () => marker, [marker]);\n\n    if (!marker) {\n      return null;\n    }\n\n    return (\n      <AdvancedMarkerContext.Provider value={advancedMarkerContextValue}>\n        {contentContainer !== null && createPortal(children, contentContainer)}\n      </AdvancedMarkerContext.Provider>\n    );\n  }\n);\n\nexport function useAdvancedMarkerRef() {\n  const [marker, setMarker] =\n    useState<google.maps.marker.AdvancedMarkerElement | null>(null);\n\n  const refCallback = useCallback((m: AdvancedMarkerRef | null) => {\n    setMarker(m);\n  }, []);\n\n  return [refCallback, marker] as const;\n}\n","/* eslint-disable complexity */\nimport React, {\n  PropsWithChildren,\n  useContext,\n  useEffect,\n  useRef,\n  useState\n} from 'react';\nimport {createPortal} from 'react-dom';\n\nimport {GoogleMapsContext} from './map';\n\n/**\n * Props for the Info Window Component\n */\nexport type InfoWindowProps = google.maps.InfoWindowOptions & {\n  onCloseClick?: () => void;\n  anchor?: google.maps.Marker | google.maps.marker.AdvancedMarkerElement | null;\n  shouldFocus?: boolean;\n};\n\n/**\n * Component to render a Google Maps Info Window\n */\nexport const InfoWindow = (props: PropsWithChildren<InfoWindowProps>) => {\n  const {children, anchor, shouldFocus, onCloseClick, ...infoWindowOptions} =\n    props;\n  const map = useContext(GoogleMapsContext)?.map;\n\n  const infoWindowRef = useRef<google.maps.InfoWindow | null>(null);\n  const [contentContainer, setContentContainer] =\n    useState<HTMLDivElement | null>(null);\n\n  // create infowindow once map is available\n  useEffect(() => {\n    if (!map) return;\n\n    const newInfowindow = new google.maps.InfoWindow(infoWindowOptions);\n\n    // Add content to info window\n    const el = document.createElement('div');\n    newInfowindow.setContent(el);\n\n    infoWindowRef.current = newInfowindow;\n    setContentContainer(el);\n\n    // Cleanup info window and event listeners on unmount\n    return () => {\n      google.maps.event.clearInstanceListeners(newInfowindow);\n\n      newInfowindow.close();\n      el.remove();\n\n      setContentContainer(null);\n    };\n\n    // `infoWindowOptions` is missing from dependencies:\n    //\n    // we don't want to re-render a whole new infowindow\n    // when the options change to prevent flickering.\n    // Update of infoWindow options is handled in the useEffect below.\n    //\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map, children]);\n\n  // Update infoWindowOptions\n  useEffect(() => {\n    infoWindowRef.current?.setOptions(infoWindowOptions);\n  }, [infoWindowOptions]);\n\n  // Handle the close click callback\n  useEffect(() => {\n    if (!infoWindowRef.current) return;\n\n    let listener: google.maps.MapsEventListener | null = null;\n\n    if (onCloseClick) {\n      listener = google.maps.event.addListener(\n        infoWindowRef.current,\n        'closeclick',\n        onCloseClick\n      );\n    }\n\n    return () => {\n      if (listener) listener.remove();\n    };\n  }, [onCloseClick]);\n\n  // Open info window after content container is set\n  useEffect(() => {\n    // anchor === null means an anchor is defined but not ready yet.\n    if (!contentContainer || !infoWindowRef.current || anchor === null) return;\n\n    const openOptions: google.maps.InfoWindowOpenOptions = {map};\n\n    if (anchor) {\n      openOptions.anchor = anchor;\n    }\n\n    if (shouldFocus !== undefined) {\n      openOptions.shouldFocus = shouldFocus;\n    }\n\n    infoWindowRef.current.open(openOptions);\n  }, [contentContainer, infoWindowRef, anchor, map, shouldFocus]);\n\n  return (\n    <>{contentContainer !== null && createPortal(children, contentContainer)}</>\n  );\n};\n","const shownMessages = new Set();\n\nexport function logErrorOnce(...args: Parameters<typeof console.error>) {\n  const key = JSON.stringify(args);\n\n  if (!shownMessages.has(key)) {\n    shownMessages.add(key);\n\n    console.error(...args);\n  }\n}\n","import {useContext} from 'react';\n\nimport {APIProviderContext} from '../components/api-provider';\nimport {GoogleMapsContext} from '../components/map';\nimport {logErrorOnce} from '../libraries/errors';\n\n/**\n * Retrieves a map-instance from the context. This is either an instance\n * identified by id or the parent map instance if no id is specified.\n * Returns null if neither can be found.\n */\nexport const useMap = (id: string | null = null): google.maps.Map | null => {\n  const ctx = useContext(APIProviderContext);\n  const {map} = useContext(GoogleMapsContext) || {};\n\n  if (ctx === null) {\n    logErrorOnce(\n      'useMap(): failed to retrieve APIProviderContext. ' +\n        'Make sure that the <APIProvider> component exists and that the ' +\n        'component you are calling `useMap()` from is a sibling of the ' +\n        '<APIProvider>.'\n    );\n\n    return null;\n  }\n\n  const {mapInstances} = ctx;\n\n  // if an id is specified, the corresponding map or null is returned\n  if (id !== null) return mapInstances[id] || null;\n\n  // otherwise, return the closest ancestor\n  if (map) return map;\n\n  // finally, return the default map instance\n  return mapInstances['default'] || null;\n};\n","import {useEffect, useMemo} from 'react';\nimport {createPortal} from 'react-dom';\nimport {useMap} from '../hooks/use-map';\n\nimport type {PropsWithChildren} from 'react';\n\ntype MapControlProps = PropsWithChildren<{\n  position: ControlPosition;\n}>;\n\n/**\n * Copy of the `google.maps.ControlPosition` constants.\n * They have to be duplicated here since we can't wait for the maps API to load to be able to use them.\n */\nexport const ControlPosition = {\n  TOP_LEFT: 1,\n  TOP_CENTER: 2,\n  TOP: 2,\n  TOP_RIGHT: 3,\n  LEFT_CENTER: 4,\n  LEFT_TOP: 5,\n  LEFT: 5,\n  LEFT_BOTTOM: 6,\n  RIGHT_TOP: 7,\n  RIGHT: 7,\n  RIGHT_CENTER: 8,\n  RIGHT_BOTTOM: 9,\n  BOTTOM_LEFT: 10,\n  BOTTOM_CENTER: 11,\n  BOTTOM: 11,\n  BOTTOM_RIGHT: 12,\n  CENTER: 13,\n  BLOCK_START_INLINE_START: 14,\n  BLOCK_START_INLINE_CENTER: 15,\n  BLOCK_START_INLINE_END: 16,\n  INLINE_START_BLOCK_CENTER: 17,\n  INLINE_START_BLOCK_START: 18,\n  INLINE_START_BLOCK_END: 19,\n  INLINE_END_BLOCK_START: 20,\n  INLINE_END_BLOCK_CENTER: 21,\n  INLINE_END_BLOCK_END: 22,\n  BLOCK_END_INLINE_START: 23,\n  BLOCK_END_INLINE_CENTER: 24,\n  BLOCK_END_INLINE_END: 25\n} as const;\nexport type ControlPosition =\n  (typeof ControlPosition)[keyof typeof ControlPosition];\n\nexport const MapControl = ({children, position}: MapControlProps) => {\n  const controlContainer = useMemo(() => document.createElement('div'), []);\n  const map = useMap();\n\n  useEffect(() => {\n    if (!map) return;\n\n    const controls = map.controls[position];\n\n    controls.push(controlContainer);\n\n    return () => {\n      const controlsArray = controls.getArray();\n      // controlsArray could be undefined if the map is in an undefined state (e.g. invalid API-key, see #276\n      if (!controlsArray) return;\n\n      const index = controlsArray.indexOf(controlContainer);\n      controls.removeAt(index);\n    };\n  }, [controlContainer, map, position]);\n\n  return createPortal(children, controlContainer);\n};\n","/* eslint-disable complexity */\nimport React, {\n  forwardRef,\n  useCallback,\n  useContext,\n  useEffect,\n  useImperativeHandle,\n  useState\n} from 'react';\n\nimport {GoogleMapsContext} from './map';\n\nimport type {Ref} from 'react';\n\ntype MarkerEventProps = {\n  onClick?: (e: google.maps.MapMouseEvent) => void;\n  onDrag?: (e: google.maps.MapMouseEvent) => void;\n  onDragStart?: (e: google.maps.MapMouseEvent) => void;\n  onDragEnd?: (e: google.maps.MapMouseEvent) => void;\n  onMouseOver?: (e: google.maps.MapMouseEvent) => void;\n  onMouseOut?: (e: google.maps.MapMouseEvent) => void;\n};\n\nexport type MarkerProps = google.maps.MarkerOptions & MarkerEventProps;\n\nexport type MarkerRef = Ref<google.maps.Marker | null>;\n\nfunction useMarker(props: MarkerProps) {\n  const [marker, setMarker] = useState<google.maps.Marker | null>(null);\n  const map = useContext(GoogleMapsContext)?.map;\n\n  const {\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    onMouseOver,\n    onMouseOut,\n    ...markerOptions\n  } = props;\n\n  const {position, draggable} = markerOptions;\n\n  // create marker instance and add to the map once the map is available\n  useEffect(() => {\n    if (!map) {\n      if (map === undefined)\n        console.error('<Marker> has to be inside a Map component.');\n\n      return;\n    }\n\n    const newMarker = new google.maps.Marker(markerOptions);\n    newMarker.setMap(map);\n    setMarker(newMarker);\n\n    return () => {\n      newMarker.setMap(null);\n      setMarker(null);\n    };\n    // We do not want to re-render the whole marker when the options change.\n    // Marker options update is handled in a useEffect below.\n    // Excluding markerOptions from dependency array on purpose here.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [map]);\n\n  // attach and re-attach event-handlers when any of the properties change\n  useEffect(() => {\n    if (!marker) return;\n\n    const m = marker;\n\n    // Add event listeners\n    const gme = google.maps.event;\n\n    if (onClick) gme.addListener(m, 'click', onClick);\n    if (onDrag) gme.addListener(m, 'drag', onDrag);\n    if (onDragStart) gme.addListener(m, 'dragstart', onDragStart);\n    if (onDragEnd) gme.addListener(m, 'dragend', onDragEnd);\n    if (onMouseOver) gme.addListener(m, 'mouseover', onMouseOver);\n    if (onMouseOut) gme.addListener(m, 'mouseout', onMouseOut);\n\n    marker.setDraggable(Boolean(draggable));\n\n    return () => {\n      gme.clearInstanceListeners(m);\n    };\n  }, [\n    marker,\n    draggable,\n    onClick,\n    onDrag,\n    onDragStart,\n    onDragEnd,\n    onMouseOver,\n    onMouseOut\n  ]);\n\n  // update markerOptions (note the dependencies aren't properly checked\n  // here, we just assume that setOptions is smart enough to not waste a\n  // lot of time updating values that didn't change)\n  useEffect(() => {\n    if (!marker) return;\n    if (markerOptions) marker.setOptions(markerOptions);\n  }, [marker, markerOptions]);\n\n  // update position when changed\n  useEffect(() => {\n    // Should not update position when draggable\n    if (draggable || !position || !marker) return;\n\n    marker.setPosition(position);\n  }, [draggable, position, marker]);\n\n  return marker;\n}\n\n/**\n * Component to render a Google Maps Marker on a map\n */\nexport const Marker = forwardRef((props: MarkerProps, ref: MarkerRef) => {\n  const marker = useMarker(props);\n\n  useImperativeHandle(ref, () => marker, [marker]);\n\n  return <></>;\n});\n\nexport function useMarkerRef() {\n  const [marker, setMarker] = useState<google.maps.Marker | null>(null);\n\n  const refCallback = useCallback((m: google.maps.Marker | null) => {\n    setMarker(m);\n  }, []);\n\n  return [refCallback, marker] as const;\n}\n","import {\n  Children,\n  PropsWithChildren,\n  useContext,\n  useEffect,\n  useMemo\n} from 'react';\nimport {AdvancedMarkerContext} from './advanced-marker';\nimport {createPortal} from 'react-dom';\nimport {logErrorOnce} from '../libraries/errors';\n\n/**\n * Props for the Pin component\n */\nexport type PinProps = google.maps.marker.PinElementOptions;\n\n/**\n * Component to render a google maps marker Pin View\n */\nexport const Pin = (props: PropsWithChildren<PinProps>) => {\n  const advancedMarker = useContext(AdvancedMarkerContext)?.marker;\n  const glyphContainer = useMemo(() => document.createElement('div'), []);\n\n  // Create Pin View instance\n  useEffect(() => {\n    if (!advancedMarker) {\n      if (advancedMarker === undefined) {\n        console.error(\n          'The <Pin> component can only be used inside <AdvancedMarker>.'\n        );\n      }\n\n      return;\n    }\n\n    if (props.glyph && props.children) {\n      logErrorOnce(\n        'The <Pin> component only uses children to render the glyph if both the glyph property and children are present.'\n      );\n    }\n\n    if (Children.count(props.children) > 1) {\n      logErrorOnce(\n        'Passing multiple children to the <Pin> component might lead to unexpected results.'\n      );\n    }\n\n    const pinViewOptions: google.maps.marker.PinElementOptions = {\n      ...props\n    };\n\n    const pinElement = new google.maps.marker.PinElement(pinViewOptions);\n\n    // Set glyph to glyph container if children are present (rendered via portal).\n    // If both props.glyph and props.children are present, props.children takes priority.\n    if (props.children) {\n      pinElement.glyph = glyphContainer;\n    }\n\n    // Set content of Advanced Marker View to the Pin View element\n    advancedMarker.content = pinElement.element;\n  }, [advancedMarker, glyphContainer, props]);\n\n  return createPortal(props.children, glyphContainer);\n};\n","const mapLinear = (x: number, a1: number, a2: number, b1: number, b2: number) =>\n  b1 + ((x - a1) * (b2 - b1)) / (a2 - a1);\n\nconst getMapMaxTilt = (zoom: number) => {\n  if (zoom <= 10) {\n    return 30;\n  }\n  if (zoom >= 15.5) {\n    return 67.5;\n  }\n\n  // range [10...14]\n  if (zoom <= 14) {\n    return mapLinear(zoom, 10, 14, 30, 45);\n  }\n\n  // range [14...15.5]\n  return mapLinear(zoom, 14, 15.5, 45, 67.5);\n};\n\n/**\n * Function to limit the tilt range of the google maps map when updating the view state\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const limitTiltRange = ({viewState}: any) => {\n  const pitch = viewState.pitch;\n  const gmZoom = viewState.zoom + 1;\n  const maxTilt = getMapMaxTilt(gmZoom);\n\n  return {...viewState, fovy: 25, pitch: Math.min(maxTilt, pitch)};\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}